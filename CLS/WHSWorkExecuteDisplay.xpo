Exportfile for AOT version 1.0 or later
Formatversion: 1

***Element: CLS

; Microsoft Dynamics AX Class: WHSWorkExecuteDisplay unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #WHSWorkExecuteDisplay
    PROPERTIES
      Name                #WHSWorkExecuteDisplay
      Origin              #{B136616A-4683-46E0-A943-500BCD4BE648}
    ENDPROPERTIES
    
    METHODS
      SOURCE #addBackButton
        #container addBackButton(container   _con,
        #                        int         _newLine = 1,
        #                        int         _defaultButton = 0)
        #{
        #    container   ret = _con;
        #
        #    if (workLine.WorkType   != WHSWorkType::Pick                                        &&
        #        workLine.WorkType   != WHSWorkType::Put                                         &&
        #        workLine.WorkType   != WHSWorkType::Custom                                      &&
        #        workLine.WorkType   != WHSWorkType::Print                                       &&
        #        workLine.WorkType   != WHSWorkType::None                                        &&
        #        mode                != WHSWorkExecuteMode::Movement                             &&
        #        mode                != WHSWorkExecuteMode::MovementByTemplate                   &&
        #        mode                != WHSWorkExecuteMode::Quarantine                           &&
        #        mode                != WHSWorkExecuteMode::PurchaseOrderLineReceiving           &&
        #        mode                != WHSWorkExecuteMode::PurchaseOrderLineReceivingAndLocate  &&
        #        mode                != WHSWorkExecuteMode::PurchaseOrderItemReceiving           &&
        #        mode                != WHSWorkExecuteMode::LicensePlateReceiving                ||
        #        mode                == WHSWorkExecuteMode::Menu                                 ||
        #        mode                == WHSWorkExecuteMode::ChangeWarehouse)
        #    {
        #        ret += [this.buildControl(#RFButton, #RFBack, "@SYS56453", _newLine, '', #WHSRFUndefinedDataType, '', _defaultButton)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addButtons
        #container addButtons(container _con)
        #{
        #    container       ret = _con;
        #    boolean         createOk = true;
        #    boolean         createCancel = true;
        #    boolean         createDrop = true;
        #    boolean         createBack = true;
        #    boolean         createDone = true;
        #    boolean         createFull = true;
        #    boolean         createOverride = true;
        #    boolean         createSuggestLocation = true;
        #    boolean         createShortPick = true;
        #    boolean         createSkip = true;
        #    int             length;
        #    int             i = 1;
        #    str             controlType;
        #    str             name;
        #
        #    if (conLen(conPeek(_con, 1)) == 2)
        #    {
        #        i = 3;
        #    }
        #
        #    length = conLen(_con);
        #
        #    for (i = i; i <= length; i++)
        #    {
        #        controlType = conPeek(conPeek(_con, i), #controlType);
        #        name = conPeek(conPeek(_con, i), #name);
        #
        #        if (controlType == #RFButton)
        #        {
        #            switch (name)
        #            {
        #                case #RFOK:
        #                    createOk = false;
        #                    break;
        #
        #                case #RFDone:
        #                    createDone = false;
        #                    break;
        #
        #                case #RFBack:
        #                    createBack = false;
        #                    break;
        #
        #                case #RFCancel:
        #                    createCancel = false;
        #                    break;
        #
        #                case #RFFull:
        #                    createFull = false;
        #                    break;
        #
        #                case #RFDrop:
        #                    createDrop = false;
        #                    break;
        #
        #                case #RFOverride:
        #                    createOverride = false;
        #                    break;
        #
        #                case #RFNoLocation:
        #                    createSuggestLocation = false;
        #                    break;
        #
        #                case #RFShortPick:
        #                    createShortPick = false;
        #                    break;
        #
        #                case #RFSkip:
        #                    createSkip = false;
        #                    break;
        #            }
        #        }
        #    }
        #
        #    if (createOk)
        #    {
        #        ret = this.addOkButton(ret);
        #    }
        #
        #    if (createFull)
        #    {
        #        ret = this.addFullButton(ret);
        #    }
        #
        #    if (createDrop)
        #    {
        #        ret = this.addDropButton(ret);
        #    }
        #
        #    if (createDone)
        #    {
        #        ret = this.addDoneButton(ret);
        #    }
        #
        #    if (createBack)
        #    {
        #        ret = this.addBackButton(ret);
        #    }
        #
        #    if (createCancel)
        #    {
        #        ret = this.addCancelButton(ret);
        #    }
        #
        #    if (createOverride)
        #    {
        #        ret = this.addOverrideButton(ret);
        #    }
        #
        #    if (createSuggestLocation)
        #    {
        #        ret = this.addSuggestLocationButton(ret);
        #    }
        #
        #    if (createShortPick)
        #    {
        #        ret = this.addShortPickButton(ret);
        #    }
        #
        #    if (createSkip)
        #    {
        #        ret = this.addSkipButton(ret);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addCancelButton
        #container addCancelButton(container _con,
        #                          int       _newLine = 1,
        #                          boolean   _override = false)
        #{
        #    container           ret = _con;
        #    boolean             addCancel = true;
        #    str                 controlType;
        #    str                 name;
        #    int                 length;
        #    int                 i = 1;
        #    WHSWorkGrouping workGrouping;
        #
        #    if ((_override                                                      ||
        #         workLine.WorkType  == WHSWorkType::Pick                        ||
        #         mode               == WHSWorkExecuteMode::Movement             ||
        #         mode               == WHSWorkExecuteMode::MovementByTemplate   ||
        #         mode               == WHSWorkExecuteMode::Quarantine))
        #    {
        #        if (conLen(conPeek(_con, 1)) == 2)
        #        {
        #            i = 3;
        #        }
        #
        #        length = conLen(_con);
        #
        #        for (i = i; i <= length; ++i)
        #        {
        #            controlType = conPeek(conPeek(_con, i), #controlType);
        #            name = conPeek(conPeek(_con, i), #name);
        #
        #            if (controlType == #RFButton && name == #RFCancel)
        #            {
        #                addCancel = false;
        #            }
        #        }
        #
        #        if (addCancel)
        #        {
        #            if (mode == WHSWorkExecuteMode::SystemGrouping && workLine.WorkType == WHSWorkType::Pick)
        #            {
        #                if (!pass.exists(#AddDoneButton) && workLine.QtyWork == workLine.QtyRemain)
        #                {
        #                    ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        #                }
        #            }
        #            else if (mode == WHSWorkExecuteMode::UserGrouping && pass.exists(#WorkGroupingId))
        #            {
        #                select count(RecId) from workGrouping
        #                    where workGrouping.WorkGroupingId == pass.lookup(#WorkGroupingId);
        #
        #                if (workGrouping.RecId <= 1 && workLine.InventQtyRemain == workLine.InventQtyWork)
        #                {
        #                    ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        #                }
        #            }
        #            else
        #            {
        #                if (workLine.WorkType == WHSWorkType::Pick)
        #                {
        #                    if ((workLine.InventQtyRemain == workLine.InventQtyWork && !WHSWorkTable::isPickCompleted(workLine.WorkId)) || workLine.WorkStop)
        #                    {
        #                        if (mode    != WHSWorkExecuteMode::PickPack ||
        #                            (mode   == WHSWorkExecuteMode::PickPack &&
        #                             (!pass.exists(#TargetWorkId)           ||
        #                              workLine.WorkId == pass.lookup(#TargetWorkId))))
        #                        {
        #                            ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        #                        }
        #                    }
        #                }
        #                else
        #                {
        #                    ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        #                }
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addDoneButton
        #container addDoneButton(container _con, boolean _override = false)
        #{
        #    container   ret = _con;
        #
        #    if (workLine.WorkType   != WHSWorkType::Pick                                        &&
        #        workLine.WorkType   != WHSWorkType::Put                                         &&
        #        workLine.WorkType   != WHSWorkType::Custom                                      &&
        #        workLine.WorkType   != WHSWorkType::Print                                       &&
        #        workLine.WorkType   != WHSWorkType::None                                        &&
        #        mode                != WHSWorkExecuteMode::Movement                             &&
        #        mode                != WHSWorkExecuteMode::MovementByTemplate                   &&
        #        mode                != WHSWorkExecuteMode::Quarantine                           &&
        #        mode                != WHSWorkExecuteMode::PurchaseOrderLineReceiving           &&
        #        mode                != WHSWorkExecuteMode::PurchaseOrderLineReceivingAndLocate  &&
        #        mode                != WHSWorkExecuteMode::PurchaseOrderItemReceiving           &&
        #        mode                != WHSWorkExecuteMode::LicensePlateReceiving                &&
        #        step                != #OverrideStep1                                           &&
        #        step                != #OverrideStep2                                           &&
        #        step                != #WorkAuditTemplate                                       ||
        #        _override           == true)
        #    {
        #        ret += [this.buildControl(#RFButton, #RFDone, "@SYS112206", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #    else if (mode == WHSWorkExecuteMode::SystemGrouping &&
        #             pass.exists(#AddDoneButton)                &&
        #             workLine.WorkType == WHSWorkType::Pick     &&
        #             workLine.isFirstPick()                     &&
        #             step != #OverrideStep1                     &&
        #             step != #OverrideStep2                     &&
        #             step != #NoLocation)
        #    {
        #        ret += [this.buildControl(#RFButton, #RFDone, "@SYS112206", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addDropButton
        #container addDropButton(container   _con,
        #                        int         _newLine = 1)
        #{
        #    container   ret = _con;
        #
        #    if (workLine.WorkType   != WHSWorkType::Pick                                        &&
        #        workLine.WorkType   != WHSWorkType::Put                                         &&
        #        workLine.WorkType   != WHSWorkType::Custom                                      &&
        #        workLine.WorkType   != WHSWorkType::None                                        &&
        #        workLine.WorkType   != WHSWorkType::Print                                       &&
        #        mode                != WHSWorkExecuteMode::Movement                             &&
        #        mode                != WHSWorkExecuteMode::MovementByTemplate                   &&
        #        mode                != WHSWorkExecuteMode::Quarantine                           &&
        #        mode                != WHSWorkExecuteMode::PurchaseOrderLineReceiving           &&
        #        mode                != WHSWorkExecuteMode::PurchaseOrderLineReceivingAndLocate  &&
        #        mode                != WHSWorkExecuteMode::PurchaseOrderItemReceiving           &&
        #        mode                != WHSWorkExecuteMode::LicensePlateReceiving)
        #    {
        #        ret += [this.buildControl(#RFButton, #RFDrop, "@WAX1202", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addErrorLabel
        #container addErrorLabel(container       _con,
        #                        str             _error,
        #                        WHSRFColorText  _color = WHSRFColorText::Default)
        #{
        #    container   ret = _con;
        #
        #    ret += [this.buildControl(#RFLabel, #RFError, _error, 1, '', #WHSRFUndefinedDataType, '', 0, true, '', _color)];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addErrorLabelFromInfolog
        #/// <summary>
        #/// Adds an error message from the infolog to the specified container.
        #/// </summary>
        #/// <param name="_con">
        #/// The container to add the error to.
        #/// </param>
        #/// <param name="_startInfologLine">
        #/// The starting line from which to retrieve the infolog message; optional.
        #/// </param>
        #/// <param name="_color">
        #/// The color in which the message should appear; optional.
        #/// </param>
        #/// <returns>
        #/// The container updated with the error message.
        #/// </returns>
        #protected container addErrorLabelFromInfolog(
        #    container       _con,
        #    int             _startInfologLine   = infologLine(),
        #    WHSRFColorText  _color              = WHSRFColorText::Default)
        #{
        #    str                     errorString;
        #    int                     currentInfologLine;
        #    SysInfologMessageStruct sysInfologMessageStruct;
        #    int                     prefixDepth;
        #    SysInfoLogStr           currentPrefixes[];
        #    int                     currentPrefixesLength;
        #
        #    for (currentInfologLine = _startInfologLine; currentInfologLine <= infologLine(); currentInfologLine++)
        #    {
        #        sysInfologMessageStruct = SysInfologMessageStruct::construct(infolog.text(currentInfologLine));
        #
        #        // Iterates through the new prefix to find from where it differs from the current prefix
        #        prefixDepth = 1;
        #        while (prefixDepth <= sysInfologMessageStruct.prefixDepth() &&
        #               prefixDepth <= currentPrefixesLength &&
        #               currentPrefixes[prefixDepth] == sysInfologMessageStruct.preFixTextElement(prefixDepth))
        #        {
        #            prefixDepth++;
        #        }
        #
        #        // Writes the remaining tabbed prefixes if needed
        #        while (prefixDepth <= sysInfologMessageStruct.prefixDepth())
        #        {
        #            currentPrefixes[prefixDepth] = sysInfologMessageStruct.preFixTextElement(prefixDepth);
        #            errorString += strRep(' ', prefixDepth - 1) + sysInfologMessageStruct.preFixTextElement(prefixDepth) + '\n';
        #            prefixDepth++;
        #        }
        #
        #        currentPrefixesLength = sysInfologMessageStruct.prefixDepth();
        #
        #        // Writes the error message
        #        errorString += strRep(' ', currentPrefixesLength) + sysInfologMessageStruct.message() + '\n';
        #    }
        #
        #    return this.addErrorLabel(_con, errorString, _color);
        #}
      ENDSOURCE
      SOURCE #addExceptionButton
        #container addExceptionButton(container  _con,
        #                             int        _newLine = 1)
        #{
        #    container   ret = _con;
        #    boolean     addException = true;
        #    str         controlType;
        #    str         name;
        #    int         length;
        #    int         i = 1;
        #
        #    if (mode != WHSWorkExecuteMode::PickPack        &&
        #        mode != WHSWorkExecuteMode::UserGrouping    &&
        #        step != #ReceivingExceptionStep1            &&
        #        step != #ReceivingExceptionStep2)
        #    {
        #        if (conLen(conPeek(_con, 1)) == 2)
        #        {
        #            i = 3;
        #        }
        #
        #        length = conLen(_con);
        #
        #        for (i = i; i <= length; ++i)
        #        {
        #            controlType = conPeek(conPeek(_con, i), #controlType);
        #            name = conPeek(conPeek(_con, i), #name);
        #
        #            if (controlType == #RFButton && name == #RFException)
        #            {
        #                addException = false;
        #            }
        #        }
        #
        #        if (addException)
        #        {
        #            ret += [this.buildControl(#RFButton, #RFException, "@SYS24667", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addFullButton
        #container addFullButton(container   _con,
        #                        int         _newLine = 1)
        #{
        #    container   ret = _con;
        #
        #    if ((mode                   == WHSWorkExecuteMode::UserDirected             ||
        #         mode                   == WHSWorkExecuteMode::UserGrouping             ||
        #         mode                   == WHSWorkExecuteMode::SystemGrouping           ||
        #         mode                   == WHSWorkExecuteMode::SystemDirected           ||
        #         mode                   == WHSWorkExecuteMode::ValidatedUserDirected)   &&
        #        workLine.WorkType       == WHSWorkType::Pick                            &&
        #        WHSWorkTable::isPickCompleted(workLine.WorkId)                          &&
        #        !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)            &&
        #        workLine.ContainerId    == ""                                           &&
        #        workLine.InventQtyWork  == workLine.InventQtyRemain                     &&
        #        step                    != #SplitWork                                   &&
        #        step                    != #ShortPick                                   &&
        #        step                    != #ShortPickConf                               &&
        #        step                    != #WorkAuditTemplate)
        #    {
        #        ret += [this.buildControl(#RFButton, #RFFull, "@WAX1203", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #    else if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).AllowFullSplit        &&
        #             workLine.WorkType      ==  WHSWorkType::Pick                           &&
        #             !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)           &&
        #             workLine.InventQtyWork == workLine.InventQtyRemain                     &&
        #             workLine.ContainerId   == ""                                           &&
        #             step                   !=  #SplitWork                                  &&
        #             step                   !=  #ShortPick                                  &&
        #             step                   !=  #ShortPickConf)
        #    {
        #        ret += [this.buildControl(#RFButton, #RFFull, "@WAX1203", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addMoveLPButton
        #container addMoveLPButton(container   _con,
        #                          int         _newLine = 1)
        #{
        #    container   ret = _con;
        #
        #    if (   pass.hasValue(#LicensePlateId)
        #        && (mode == WHSWorkExecuteMode::Movement
        #        ||  mode == WHSWorkExecuteMode::MovementByTemplate))
        #    {
        #        ret += [this.buildControl(#RFButton, #RFMoveLp, "@WAX1481", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addOkButton
        #container addOkButton(container _con,
        #                      int       _newLine = 1)
        #{
        #    container   ret = _con;
        #
        #    if (workLine.WorkType   == WHSWorkType::Pick                        ||
        #        workLine.WorkType   == WHSWorkType::Put                         ||
        #        workLine.WorkType   == WHSWorkType::Custom                      ||
        #        mode                == WHSWorkExecuteMode::Movement             ||
        #        mode                == WHSWorkExecuteMode::MovementByTemplate   ||
        #        mode                == WHSWorkExecuteMode::Quarantine           ||
        #        mode                == WHSWorkExecuteMode::InquiryLocation      ||
        #        mode                == WHSWorkExecuteMode::ProductionScrap      ||
        #        mode                == WHSWorkExecuteMode::InquiryItem)
        #    {
        #        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", _newLine, '', #WHSRFUndefinedDataType, '', 1)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addOverrideButton
        #container addOverrideButton(
        #    container _con,
        #    int       _newLine = 1)
        #{
        #    InventLocation  inventLocation;
        #    container       ret = _con;
        #
        #    if (!pass.exists(#NoOverrideButton)                 &&
        #        !pass.exists(#WorkComplete)                     &&
        #        step                    != #NoLocation          &&
        #        step                    != #ShortPick           &&
        #        step                    != #ShortPickConf       &&
        #        step                    != #SplitWork           &&
        #        step                    != #RFPickingComment    &&
        #        step                    != #AssignSerialStep    &&
        #        step                    != #WorkAuditTemplate   &&
        #        WHSWorkUser::allowOverride(pass.lookup(#UserId), workLine.WorkType))
        #    {
        #        if (workLine.WorkType == WHSWorkType::Pick)
        #        {
        #            inventLocation = InventLocation::find(workTable.InventLocationId);
        #
        #            if (   !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
        #                && mode                    != WHSWorkExecuteMode::MovementByTemplate
        #                && workLine.wmsLocationId  != inventLocation.wmsLocationIdDefaultReceipt
        #                && workLine.wmsLocationId  != inventLocation.DefaultProductionFinishGoodsLocation
        #                && workLine.wmsLocationId  != inventLocation.DefaultKanbanFinishedGoodsLocation)
        #            {
        #                ret += [this.buildControl(#RFButton, #RFOverride, "@WAX1280", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        #            }
        #        }
        #        else
        #        {
        #            if (!WHSWorkTable::find(workLine.WorkId).isReplenDemand())
        #            {
        #                ret += [this.buildControl(#RFButton, #RFOverride, "@WAX1280", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addShortPickButton
        #container addShortPickButton(container  _con,
        #                             int        _newLine = 1)
        #{
        #    container   ret = _con;
        #
        #    if (   (mode                   == WHSWorkExecuteMode::UserDirected
        #        ||  mode                   == WHSWorkExecuteMode::SystemDirected
        #        ||  mode                   == WHSWorkExecuteMode::SystemGrouping
        #        ||  mode                   == WHSWorkExecuteMode::UserGrouping
        #        ||  mode                   == WHSWorkExecuteMode::ValidatedUserDirected)
        #        && workLine.WorkType       == WHSWorkType::Pick
        #        && !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
        #        && step                    != #ShortPick
        #        && step                    != #ShortPickConf
        #        && step                    != #NoLocation
        #        && step                    != #OverrideStep1
        #        && step                    != #OverrideStep2
        #        && step                    != #SplitWork
        #        && step                    != #RFPickingComment
        #        && step                    != #AssignSerialStep
        #        && step                    != #WorkAuditTemplate
        #        && workTable.WorkTransType != WHSWorkTransType::ProdPick
        #        && workTable.WorkTransType != WHSWorkTransType::KanbanPick)
        #    {
        #        if (   !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)
        #            && workLine.wmsLocationId != InventLocation::find(workTable.InventLocationId).wmsLocationIdDefaultReceipt
        #            && workLine.wmsLocationId != InventLocation::find(workTable.InventLocationId).DefaultProductionFinishGoodsLocation
        #            && workLine.wmsLocationId != InventLocation::find(workTable.InventLocationId).DefaultKanbanFinishedGoodsLocation)
        #        {
        #            ret += [this.buildControl(#RFButton, #RFShortPick, "@WAX1322", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addSkipButton
        #container addSkipButton(container   _con,
        #                        int         _newLine = 1)
        #{
        #    container   ret = _con;
        #
        #    // Only show the Skip button for Pick's which aren't the last Pick or system directed menu items
        #    if (workLine.WorkType       == WHSWorkType::Pick                            &&
        #        step                    != #ShortPick                                   &&
        #        step                    != #ShortPickConf                               &&
        #        step                    != #NoLocation                                  &&
        #        step                    != #OverrideStep1                               &&
        #        step                    != #OverrideStep2                               &&
        #        step                    != #SplitWork                                   &&
        #        step                    != #RFPickingComment                            &&
        #        step                    != #WorkAuditTemplate                           &&
        #        workLine.InventQtyWork  == workLine.InventQtyRemain                     &&
        #        (!workLine.isLastRemainingPick()                                        ||
        #         mode == WHSWorkExecuteMode::SystemGrouping                             ||
        #         WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).MenuItemDirectedBy == WHSMenuItemDirectedBy::SystemDirected))
        #    {
        #        ret += [this.buildControl(#RFButton, #RFSkip, "@WAX3534", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addSuggestLocationButton
        #container addSuggestLocationButton(container    _con,
        #                                   boolean      _override = false)
        #{
        #    container   ret = _con;
        #
        #    if (step == #NoLocation || step == #ShortPickConf || _override)
        #    {
        #        ret += [this.buildControl(#RFButton, #RFNoLocation, "@WAX1281", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addTrackingDimRecUOMControl
        #/// <summary>
        #///     Adds the batch UOM control to the RF container.
        #/// </summary>
        #/// <param name="_con">
        #///     The RF container variable.
        #/// </param>
        #/// <param name="_label">
        #///     The label to be used for the control.
        #/// </param>
        #/// <param name="_elements">
        #///     The elements to be included in the combobox.
        #/// </param>
        #/// <param name="_selected">
        #///     A Boolean value indiciating the value that must be selected from the list of available options.
        #/// </param>
        #/// <param name="_enabled">
        #///     A Boolean value indicating whether the control is enabled for edit.
        #/// </param>
        #/// <returns>
        #///     Returns the updated RF container variable.
        #/// </returns>
        #protected container addTrackingDimRecUOMControl(
        #    container   _con,
        #    str         _label,
        #    str         _elements,
        #    str         _selected,
        #    boolean     _enabled)
        #{
        #    container   ret = _con;
        #    str         label;
        #
        #    label =  _label ? _label : "@WAX721";   // UOM
        #
        #    if (!_enabled && _selected)
        #    {
        #        ret += [this.buildControl(#RFCombobox, #DimUOM, label, 1, _selected, #WHSRFUndefinedDataType, '', 0, _enabled, _selected)];
        #    }
        #    else
        #    {
        #        ret += [this.buildControl(#RFCombobox, #DimUOM, label, 1, _elements, #WHSRFUndefinedDataType, '', 0, _enabled, _selected ? _selected : '')];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildAboveLocationDimensions
        #/// <summary>
        #/// Method builds label controls on the RF screen for all dimensions above location in the reservation hierarchy.
        #/// </summary>
        #/// <param name="_con">
        #/// A container holding all the current RF screen information
        #/// </param>
        #/// <param name="_inventDim">
        #/// The inventDim holding values to be displayed.
        #/// </param>
        #/// <param name="_itemId">
        #/// The Id of the item which determines the reservation hierarchy, thus, determining the dimensions above locaiton.
        #/// </param>
        #/// <returns>
        #/// A container with the updated RF screen information
        #/// </returns>
        #protected container buildAboveLocationDimensions(
        #    container   _con,
        #    InventDim   _inventDim,
        #    ItemId      _itemId)
        #{
        #    WHSReservationHierarchyProvider     reservationHierarchyProvider;
        #    WHSReservationHierarchyElementData  hierarchyElementData;
        #    container                           ret = _con;
        #    ListEnumerator                      le;
        #    FieldId                             dimFieldId;
        #    boolean                             displayInventStatus;
        #
        #    // Method to build the dimension control
        #    container buildDimControl(InventDim _internalInventDim, FieldId _internalDimFieldId)
        #    {
        #        return [this.buildControl(#RFLabel,
        #                    fieldId2name(tableNum(InventDim), _internalDimFieldId),
        #                    strFmt("%1: %2", new DictField(tableNum(InventDim), _internalDimFieldId).label(), _internalInventDim.(_internalDimFieldId)),
        #                    1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #    }
        #
        #    if (_itemId)
        #    {
        #        reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();
        #        displayInventStatus = WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).rfDisplayStatus;
        #
        #        // Add product dimensions
        #        le = InventDimGroupSetup::newItemIdProductDimensionsOnly(_itemId).activeFields().getEnumerator();
        #        while (le.moveNext())
        #        {
        #            dimFieldId = le.current();
        #            if (_inventDim.(dimFieldId))
        #            {
        #                ret += buildDimControl(_inventDim, dimFieldId);
        #            }
        #        }
        #
        #        // Add dimensions from hierarchy
        #        le = reservationHierarchyProvider.getDimListAboveLocationFromInventTable(
        #                    InventTable::find(_itemId),
        #                    WHSReservationHierarchySortOrder::TopDown)
        #                .getEnumerator();
        #        while (le.moveNext())
        #        {
        #            hierarchyElementData = le.current();
        #            dimFieldId = hierarchyElementData.parmDimensionFieldId();
        #
        #            // Filter out status, warehouse and site.
        #            if (_inventDim.(dimFieldId)
        #                && dimFieldId != fieldNum(InventDim, InventLocationId)
        #                && dimFieldId != fieldNum(InventDim, InventSiteId)
        #                && (dimFieldId != fieldNum(InventDim, InventStatusId)
        #                    || displayInventStatus))
        #            {
        #                ret += buildDimControl(_inventDim, dimFieldId);
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildAdjustInTrackingDimensions
        #protected container buildAdjustInTrackingDimensions(
        #    container   _con,
        #    ItemId      _itemId)
        #{
        #    container       ret = _con;
        #    ListEnumerator  le;
        #    str             dateFormat = WHSParameters::getDateFormat();
        #
        #    le = InventDimGroupSetup::newDimensionGroups(0, 0, InventTable::find(_itemId).trackingDimensionGroup()).activeFields().getEnumerator();
        #
        #    while (le.moveNext())
        #    {
        #        switch (le.current())
        #        {
        #            case fieldNum(InventDim, InventBatchId):
        #                ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, '', extendedTypeNum(InventBatchId), '', 0)];
        #
        #                if (pass.exists(#BatchId) && pass.lookup(#BatchId) != '')
        #                {
        #                    if (InventBatch::exist(pass.lookup(#ItemId), pass.lookup(#BatchId)))
        #                    {
        #                        ret += [this.buildControl(#RFText, #ExpDate, strFmt("@WAX1769", dateFormat), 1, strFmt('%1', InventBatch::find(pass.lookup(#BatchId), pass.lookup(#ItemId)).ExpDate), extendedTypeNum(InventBatchExpDate), '', 0, false)];
        #                    }
        #                    else
        #                    {
        #                        if (!pass.exists(#ExpDate) && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).DefaultData)
        #                        {
        #                            ret += [this.buildControl(#RFText, #ExpDate, strFmt("@WAX1769", dateFormat), 1, WHSRFDefaultData::getDefaultValue(pass.lookup(#MenuItem),
        #                                                                                                                                              WHSDefaultDataField::ExpDate,
        #                                                                                                                                              pass.lookup(#UserId),
        #                                                                                                                                              pass.lookup(#InventLocationId),
        #                                                                                                                                              pass.lookup(#WMSLocationId)), extendedTypeNum(InventBatchExpDate), '', 0)];
        #                        }
        #                        else
        #                        {
        #                            ret += [this.buildControl(#RFText, #ExpDate, strFmt("@WAX1769", dateFormat), 1, '', extendedTypeNum(InventBatchExpDate), '', 0)];
        #                        }
        #                    }
        #                }
        #                break;
        #
        #            case fieldNum(InventSerial, InventSerialId):
        #                if (WHSInventTable::captureSerial(_itemId) == WHSRFWhenToCapture::Receiving)
        #                {
        #                    ret += [this.buildControl(#RFText, #SerialId, "@WAX1614", 1, '', extendedTypeNum(InventSerialId), '', 0)];
        #                }
        #                break;
        #
        #            default:
        #                ret += [this.buildControlForTableField(tableNum(InventDim), le.current(), fieldId2name(tableNum(InventDim), le.current()), 1, '', true)];
        #                break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildAdjustmentType
        #container buildAdjustmentType(container    _con,
        #                              str          _label = '',
        #                              boolean      _showRemove = false,
        #                              boolean      _showBlank = false,
        #                              boolean      _showOK = true,
        #                              str          _selected = '')
        #{
        #    WHSAdjustmentType   adjustmentType;
        #    container           ret = _con;
        #    boolean             first = true;
        #    str                 elements;
        #    str                 label = _label ? _label : "@SYS17769";      // Adjustment Type
        #    ;
        #
        #    if (_showBlank)
        #    {
        #        elements = '||';
        #    }
        #
        #    while select AdjustmentTypeCode from adjustmentType
        #    {
        #        if (first)
        #        {
        #            elements += adjustmentType.AdjustmentTypeCode;
        #            first = false;
        #        }
        #        else
        #        {
        #            elements = elements + '||' + adjustmentType.AdjustmentTypeCode;
        #        }
        #    }
        #
        #    ret += [this.buildControl(#RFCombobox, #AdjustmentType, label, 1, elements, #WHSRFUndefinedDataType, '', 0, true, _selected ? _selected : WHSRFMenuItemTable::getDefaultAdjustmentTypeCode(pass.lookup(#MenuItem)))];
        #    pass.insert(#SelectedAdjustmentType, _selected ? _selected : WHSRFMenuItemTable::getDefaultAdjustmentTypeCode(pass.lookup(#MenuItem)));
        #
        #    if (_showRemove)
        #    {
        #        ret += [this.buildControl(#RFButton, "@SYS26394", "@WAX879", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #
        #    if (_showOK)
        #    {
        #        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildAssignSerial
        #container buildAssignSerial(container _con, str _extraText = '')
        #{
        #    container   ret = _con;
        #    str         finalLabel = _extraText ? _extraText : "@WAX3318";
        #
        #    ret += [this.buildControl(#RFLabel, #Enter, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];
        #
        #    if (pass.exists(#LicensePlateId))
        #    {
        #        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookup(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        #    }
        #
        #    ret += [this.buildControl(#RFText, #ItemId, "@SYS111673", 1, pass.lookupStr(#ItemId), extendedTypeNum(ItemId), '', 0, false)];
        #
        #    // Build control to capture next dimension
        #    // No need to prompt for dimension if raw material picking in a license plate controlled location since full LP qty is picked
        #    ret = this.buildNextDimensionCaptureControl(ret, workLine.inventDimWithLocation(), workLine.ItemId, workLine.InventQtyRemain, true, true);
        #
        #    ret += [this.buildControl(#RFButton, 'OK', "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildBatchDisposition
        #/// <summary>
        #///     Builds the batch disposition control on the RF screen.
        #/// </summary>
        #/// <param name="_con">
        #///     The RF container variable.
        #/// </param>
        #/// <param name="_controlName">
        #///     The name used to identify the RF control.
        #/// </param>
        #/// <param name="_label">
        #///     The label to be used for the RF control.
        #/// </param>
        #/// <param name="_editable">
        #///     A Boolean value indicating whether the control is editable.
        #/// </param>
        #/// <returns>
        #///     Returns the updated RF container variable.
        #/// </returns>
        #protected container buildBatchDisposition(
        #    container       _con,
        #    str             _controlName = #BatchDisposition,
        #    str             _label = "@PRO173",
        #    boolean         _editable = true)
        #{
        #    container               ret = _con;
        #    ItemId                  itemId;
        #    PdsBatchDispositionCode defaultValue;
        #    PdsBatchDispositionCode selectedValue;
        #    str                     elements;
        #    boolean                 showBlank;
        #
        #    if (this.displayBatchDisposition())
        #    {
        #        itemId = pass.lookupStr(#ItemId);
        #
        #        // Get the default batch disposition code.
        #        [defaultValue, showBlank] = this.getDefaultBatchDispositionCode(itemId);
        #
        #        // If the batch ID has changed, reset the selected value to the default.
        #        if (pass.exists(#ResetBatchDisposition))
        #        {
        #            selectedValue = defaultValue;
        #
        #            pass.remove(#ResetBatchDisposition);
        #        }
        #        else
        #        {
        #            selectedValue = pass.lookupStr(_controlName);
        #        }
        #
        #        // Build the batch disposition elements.
        #        elements = this.buildBatchDispositionElements(showBlank);
        #
        #        ret += [this.buildControl(#RFComboBox, _controlName, _label, 1, elements, #WHSRFUndefinedDataType, '', 0, _editable, selectedValue ? selectedValue : defaultValue)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildBatchDispositionElements
        #/// <summary>
        #///     Builds a pipe-delimited string containing batch disposition values.
        #/// </summary>
        #/// <param name="_showBlank">
        #///     A Boolean value to indicate whether a blank value should be included in the list of available options.
        #/// </param>
        #/// <returns>
        #///     Returns a pipe-delimited string containing batch disposition values.
        #/// </returns>
        #protected str buildBatchDispositionElements(boolean _showBlank)
        #{
        #    PdsDispositionMaster    pdsDispositionMaster;
        #    boolean                 first = true;
        #    str                     elements;
        #
        #    if (_showBlank)
        #    {
        #        elements = '||';
        #    }
        #    if (pass.exists(#ItemId))
        #    {
        #        while select DispositionCode from pdsDispositionMaster
        #        {
        #            if (first)
        #            {
        #                first = false;
        #            }
        #            else
        #            {
        #                elements += '||';
        #            }
        #
        #            elements += pdsDispositionMaster.DispositionCode;
        #        }
        #    }
        #
        #    return elements;
        #}
      ENDSOURCE
      SOURCE #buildBatchExpDate
        #/// <summary>
        #///     Builds the batch expiration date control on the RF screen.
        #/// </summary>
        #/// <param name="_con">
        #///     The RF container variable.
        #/// </param>
        #/// <returns>
        #///     Returns the updated RF container variable.
        #/// </returns>
        #protected container buildBatchExpDate(container _con)
        #{
        #    container   ret = _con;
        #    str         expDate;
        #    InventBatch inventBatch;
        #    InventTable inventTable;
        #    boolean     enabled;
        #    str         dateFormat = WHSParameters::getDateFormat();
        #
        #    inventTable = InventTable::find(pass.lookupStr(#ItemId));
        #
        #    // For shelf life items, expiration date is calculated at registration rather than being captured through the RF.
        #    if (!inventTable.isShelfLifeItem())
        #    {
        #        inventBatch = InventBatch::find(this.getInventBatchId(), inventTable.ItemId);
        #
        #        expDate = pass.exists(#VendBatchInfoEntered) ? pass.lookupStr(#ExpDate) : strFmt("%1", inventBatch.ExpDate);
        #        enabled = !pass.exists(#VendBatchInfoEntered) && inventBatch.RecId == 0;
        #
        #        ret += [this.buildControl(#RFText, #ExpDate, strFmt("@WAX1769", dateFormat), 1, expDate, extendedTypeNum(InventBatchExpDate), '', 0, enabled)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildBatchOverrideIfMenuItemAllows
        #/// <summary>
        #///     If the menu item allows batch number override, build the batch control elements.
        #/// </summary>
        #/// <param name="_con">
        #///     The RF container variable.
        #/// </param>
        #/// <param name="_inventBatchId">
        #///     The original inventory batch ID.
        #/// </param>
        #/// <param name="_licensePlateId">
        #///     The license plate ID.
        #/// </param>
        #/// <returns>
        #///     Returns the updated RF container variable.
        #/// </returns>
        #protected container buildBatchOverrideIfMenuItemAllows(
        #    container           _con,
        #    InventBatchId       _inventBatchId,
        #    WHSLicensePlateId   _licensePlateId)
        #{
        #    container           ret = _con;
        #    InventBatchId       batchId;
        #    WHSRFMenuItemTable  menuItemTable;
        #    str                 defaultValue;
        #    boolean             editable = true;
        #    InventBatch         inventBatch;
        #    str                 dateFormat = WHSParameters::getDateFormat();
        #    InventTable         inventTable;
        #
        #    menuItemTable = WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem));
        #
        #    if (menuItemTable.OverrideInventBatchId
        #        && pass.hasValue(#ItemId)
        #        && InventTable::find(pass.lookup(#ItemId)).isItemBatchActivated())
        #    {
        #        inventTable = InventTable::find(pass.lookup(#ItemId));
        #
        #        if (!pass.exists(#BatchId) && _inventBatchId)
        #        {
        #            pass.insert(#BatchId, _inventBatchId);
        #        }
        #
        #        batchId = pass.lookupStr(#BatchId);
        #
        #        ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, batchId, extendedTypeNum(InventBatchId), '', 0)];
        #
        #        if (!inventTable.isShelfLifeItem())
        #        {
        #            inventBatch = InventBatch::find(batchId, inventTable.ItemId);
        #
        #            if (inventBatch.RecId != 0)
        #            {
        #                defaultValue    = strFmt("%1", inventBatch.ExpDate);
        #                editable        = false;
        #            }
        #            else if (!pass.exists(#ExpDate) && menuItemTable.DefaultData)
        #            {
        #                defaultValue =  WHSRFDefaultData::getDefaultValue(pass.lookup(#MenuItem),
        #                                    WHSDefaultDataField::ExpDate,
        #                                    pass.lookup(#UserId),
        #                                    pass.lookup(#InventLocationId),
        #                                    pass.lookup(#WMSLocationId));
        #            }
        #
        #            ret += [this.buildControl(#RFText, #ExpDate, strFmt("@WAX1769", dateFormat), 1, defaultValue, extendedTypeNum(InventBatchExpDate), '', 0, editable)];
        #        }
        #        else if (InventBatch::exist(inventTable.ItemId, batchId))
        #        {
        #            editable = false;
        #        }
        #
        #        // Build the batch disposition control.
        #        ret = this.buildBatchDisposition(ret);
        #
        #        // For the sake of adding a grouping header for the potency control, we must add LP prior to adding potency on the RF screen.
        #        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, _licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0)];
        #
        #        // Build the potency control.
        #        ret = this.buildGetPotency(ret, batchId);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildComments
        #container buildComments(container   _con)
        #{
        #    container           ret = _con;
        #    WHSShipmentTable    shipmentTable;
        #    DocuRef             docuRef;
        #    WHSWorkLine         pickLine;
        #    WHSWorkLine         firstPutLine;
        #    WHSParameters       parameters = WHSParameters::find();
        #    str                 notes;
        #    WHSShipmentId       prevShipment;
        #    RecId               prevDocu;
        #    int                 numOfPicks;
        #    Qty                 inventUnits;
        #    Weight              totalWeight;
        #    WHSWorkLine         tmpWorkLine;
        #
        #    if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).rfDisplayPickSummary)
        #    {
        #        while select WorkType, InventQtyWork, ItemId from tmpWorkLine
        #            order by LineNum
        #            where tmpWorkLine.WorkId == workLine.WorkId
        #        {
        #            if (tmpWorkLine.WorkType == WHSWorkType::Pick)
        #            {
        #                ++numOfPicks;
        #                inventUnits += tmpWorkLine.InventQtyWork;
        #                totalWeight += tmpWorkLine.InventQtyWork * InventTable::find(tmpWorkLine.ItemId).grossWeight();
        #            }
        #            else if (tmpWorkLine.WorkType == WHSWorkType::Put)
        #            {
        #                break;
        #            }
        #        }
        #
        #        ret += [this.buildControl(#RFLabel, #Comments, strFmt("@WAX2958", numOfPicks), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #        ret += [this.buildControl(#RFLabel, #Comments, strFmt("@WAX2959", inventUnits), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #        ret += [this.buildControl(#RFLabel, #Comments, strFmt("@WAX2960", totalWeight, '\n'), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #
        #    select firstonly LineNum, WorkId from firstPutLine
        #        order by LineNum desc
        #        where firstPutLine.WorkId   == workLine.WorkId &&
        #              firstPutLine.WorkType == WHSWorkType::Put;
        #
        #    while select LineNum, WorkId, ShipmentId from pickLine
        #        join ShipmentId from shipmentTable
        #        order by shipmentTable.ShipmentId
        #        where pickLine.LineNum      <  firstPutLine.LineNum    &&
        #              pickLine.WorkId       == firstPutLine.WorkId  &&
        #              pickLine.ShipmentId   == shipmentTable.ShipmentId
        #    {
        #        if (prevShipment != shipmentTable.ShipmentId)
        #        {
        #            while select docuRef
        #                order by docuRef.RecId asc
        #                where docuRef.RefTableId    == shipmentTable.TableId    &&
        #                      docuRef.RefRecId      == shipmentTable.RecId      &&
        #                      docuRef.TypeId        == parameters.rfNoteType
        #            {
        #                if (prevDocu != docuRef.RecId)
        #                {
        #                    notes += docuRef.Notes + '\n';
        #                    prevDocu = docuRef.RecId;
        #                }
        #            }
        #            if (notes)
        #            {
        #                ret += [this.buildControl(#RFLabel, #Comments, strFmt("@WAX2500", shipmentTable.ShipmentId, '\n', notes), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #            }
        #            prevShipment = shipmentTable.ShipmentId;
        #            notes = '';
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildConfirmScreen
        #container buildConfirmScreen(container _con, str _message)
        #{
        #    container           ret = _con;
        #    WHSWorkTypeCustom   workTypeCustom;
        #
        #    workTypeCustom = WHSWorkTypeCustom::find(workLine.WorkTypeCustomCode);
        #
        #    ret += [this.buildControl(#RFLabel, #Confirmation, _message, 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    if (workTypeCustom.CaptureData)
        #    {
        #        ret += [this.buildControl(#RFText, #Custom, workTypeCustom.rfLabel, 1, '', extendedTypeNum(Description), '', 0)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildControl
        #container buildControl(str                  _controlType,
        #                       str                  _name,
        #                       str                  _label,
        #                       int                  _newLine,
        #                       str                  _data,
        #                       ExtendedTypeId       _inputType,
        #                       str                  _error,
        #                       int                  _defaultButton,
        #                       boolean              _enabled = true,
        #                       str                  _selected = '',
        #                       WHSRFColorText       _color = WHSRFColorText::Default)
        #{
        #    container   ret         = conNull();
        #    int         length      = -1;
        #    str         typeStr     = #TypeUndefined;
        #    SysDictType sysTypeDict = new SysDictType(_inputType);
        #    Types       type;
        #
        #    if (_inputType != #WHSRFUndefinedDataType && sysTypeDict)
        #    {
        #        type    = sysTypeDict.isTime() ? Types::Time : sysTypeDict.baseType();
        #        typeStr = enum2Symbol(enumNum(Types), type);
        #        if (type == Types::String)
        #        {
        #            length = sysTypeDict.stringLen();
        #        }
        #    }
        #
        #    ret = [_controlType];
        #    ret += _name;
        #    ret += _label;
        #    ret += _newLine;
        #    ret += _data;
        #    ret += typeStr;
        #    ret += length;
        #    ret += _error == '' ? '0' : '1';
        #    ret += _defaultButton;
        #    ret += _enabled ? 1 : 0;
        #    ret += _selected;
        #    ret += WHSRFColor::getHexColor(_color);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildControlForTableField
        #/// <summary>
        #///    Builds a control based on a table field.
        #/// </summary>
        #/// <param name="_tableId">
        #///    The table ID of the field.
        #/// </param>
        #/// <param name="_fieldId">
        #///    The field ID.
        #/// </param>
        #/// <param name="_name">
        #///    The name of the control.
        #/// </param>
        #/// <param name="_newLine">
        #///    The new line value for the control.
        #/// </param>
        #/// <param name="_data">
        #///    The control value.
        #/// </param>
        #/// <param name="_enabled">
        #///    A Boolean value that indicates if the field is enabled.
        #/// </param>
        #/// <returns>
        #///    A container that represents the control.
        #/// </returns>
        #protected container buildControlForTableField(
        #    TableId _tableId,
        #    FieldId _fieldId,
        #    str     _name,
        #    int     _newLine,
        #    str     _data,
        #    boolean _enabled)
        #{
        #    container   result;
        #
        #    DictType    dictType = WHSWorkExecuteDisplay::dictTypeForTableField(_tableId,_fieldId);
        #
        #    if (dictType)
        #    {
        #        result = this.buildControl(#RFText,_name,dictType.label(),_newLine,_data, dictType.id() ,'',0,_enabled);
        #    }
        #
        #    return result;
        #}
      ENDSOURCE
      SOURCE #buildCycleCountUOM
        #container buildCycleCountUOM(container    _con,
        #                             str          _label = '',
        #                             boolean      _showBlank = false,
        #                             str          _selected = '')
        #{
        #    WHSInventTable      whsInventTable;
        #    WHSUOMSeqGroupLine  uomSeqGroupLine;
        #    container           ret = _con;
        #    boolean             first = true;
        #    str                 elements;
        #    str                 label = _label ? _label : "@WAX721";      // UOM
        #    int                 countUOM = 0;
        #    ItemId              itemId;
        #
        #    if (pass.exists(#ItemId))
        #    {
        #        itemId = pass.lookup(#ItemId);
        #        whsInventTable = WHSInventTable::find(itemId);
        #    }
        #
        #    if (!WHSUOMSeqGroupTable::hasCycleCountUOM(whsInventTable.uomSeqGroupId))
        #    {
        #        ret += [this.buildControl(#RFText, #CycleCountQty1, "@SYS105177", 1, '', extendedTypeNum(Qty), '', 0)];
        #
        #        elements = this.buildUOMSequenceGroupString(itemId, _showBlank);
        #
        #        ret += [this.buildControl(#RFCombobox, #CycleCountUOM1, label, 0, elements, #WHSRFUndefinedDataType, '', 0, true, _selected ? _selected : '')];
        #    }
        #    else
        #    {
        #        while select reverse UnitId from uomSeqGroupLine
        #            where uomSeqGroupLine.uomSeqGroupId  == whsInventTable.uomSeqGroupId  &&
        #                  uomSeqGroupLine.CycleCountUOM  == NoYes::Yes
        #        {
        #            if (countUOM < 4)
        #            {
        #                switch (countUOM)
        #                {
        #                    case 0:
        #                        ret += [this.buildControl(#RFText, #CycleCountQty1, "@SYS105177", 1, '', extendedTypeNum(Qty), '', 0)];
        #                        ret += [this.buildControl(#RFCombobox, #CycleCountUOM1, label, 0, uomSeqGroupLine.UnitId, #WHSRFUndefinedDataType, '', 0, false, uomSeqGroupLine.UnitId)];
        #                        countUOM++;
        #                        break;
        #
        #                    case 1:
        #                        ret += [this.buildControl(#RFText, #CycleCountQty2, "@SYS105177", 1, '', extendedTypeNum(Qty), '', 0)];
        #                        ret += [this.buildControl(#RFCombobox, #CycleCountUOM2, label, 0, uomSeqGroupLine.UnitId, #WHSRFUndefinedDataType, '', 0, false, uomSeqGroupLine.UnitId)];
        #                        countUOM++;
        #                        break;
        #
        #                    case 2:
        #                        ret += [this.buildControl(#RFText, #CycleCountQty3, "@SYS105177", 1, '', extendedTypeNum(Qty), '', 0)];
        #                        ret += [this.buildControl(#RFCombobox, #CycleCountUOM3, label, 0, uomSeqGroupLine.UnitId, #WHSRFUndefinedDataType, '', 0, false, uomSeqGroupLine.UnitId)];
        #                        countUOM++;
        #                        break;
        #
        #                    case 3:
        #                        ret += [this.buildControl(#RFText, #CycleCountQty4, "@SYS105177", 1, '', extendedTypeNum(Qty), '', 0)];
        #                        ret += [this.buildControl(#RFCombobox, #CycleCountUOM4, label, 0, uomSeqGroupLine.UnitId, #WHSRFUndefinedDataType, '', 0, false, uomSeqGroupLine.UnitId)];
        #                        countUOM++;
        #                        break;
        #                }
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildDispositon
        #/// <summary>
        #/// Builds a list of disposition codes to be used within the RF
        #/// </summary>
        #/// <param name="_con">
        #/// Container holding RF information
        #/// </param>
        #/// <param name="_selected">
        #/// Selected value for disposition control
        #/// </param>
        #/// <param name="_enabled">
        #/// Determines if control is enabled or not
        #/// </param>
        #/// <param name="_addEmpty">
        #/// Determines if an empty entry should be added as the first disposition code
        #/// </param>
        #/// <returns>
        #/// Container with disposition values
        #/// </returns>
        #public container buildDispositon(
        #    container    _con,
        #    str          _selected = '',
        #    boolean      _enabled = true,
        #    boolean      _addEmpty = false)
        #{
        #    container           ret = _con;
        #    boolean             first = true;
        #    str                 elements;
        #    WHSDispositionTable dispositionTable;
        #    WHSDispositionCode  dispositionCode;
        #    str                 selected = _selected;
        #
        #    elements = '';
        #
        #    if (_addEmpty)
        #    {
        #        elements += '||';
        #    }
        #
        #    while select dispositionTable
        #    {
        #        if (first)
        #        {
        #            if (this.showDisposition(dispositionTable))
        #            {
        #                elements += dispositionTable.DispositionCode;
        #                first = false;
        #            }
        #        }
        #        else
        #        {
        #            if (this.showDisposition(dispositionTable))
        #            {
        #                elements = elements + '||' + dispositionTable.DispositionCode;
        #            }
        #        }
        #    }
        #
        #    if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).DefaultData)
        #    {
        #        dispositionCode = WHSRFDefaultData::getDefaultValue(pass.lookup(#MenuItem),
        #                                                            WHSDefaultDataField::Disposition,
        #                                                            pass.lookup(#UserId),
        #                                                            pass.lookupStr(#InventLocationId),
        #                                                            pass.lookupStr(#WMSLocationId));
        #    }
        #
        #    if (!selected && dispositionCode)
        #    {
        #        selected = dispositionCode;
        #    }
        #
        #    ret += [this.buildControl(#RFCombobox, #Disposition, "@WAX1841", 1, elements, #WHSRFUndefinedDataType, '', 0, _enabled, selected ? selected : '')];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildGetBatchLoop
        #container buildGetBatchLoop(container     _con,
        #                            Qty           _defaultQty,
        #                            str           _extraText = '')
        #{
        #    container       ret = _con;
        #    WMSLocation     location;
        #
        #    location = WMSLocation::find(pass.lookup(#WMSLocationId), pass.lookup(#InventLocationId));
        #
        #    ret += [this.buildControl(#RFLabel, #BatchLoop, "@WAX2009", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    if (location.whsLocationIsLPControlled())
        #    {
        #        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookup(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        #    }
        #    else
        #    {
        #        ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];
        #    }
        #
        #    if (_defaultQty)
        #    {
        #        ret += [this.buildControl(#RFText, #BatchQtyToPick, "@WAX2011", 1, WHSWorkExecuteDisplay::num2StrDisplay(_defaultQty), extendedTypeNum(Qty), '', 0, false)];
        #        ret += [this.buildControl(#RFText, #BatchQtyPicked, "@WAX2012", 1, '0', extendedTypeNum(Qty), '', 0, false)];
        #
        #    }
        #    else
        #    {
        #        ret += [this.buildControl(#RFText, #BatchQtyToPick, "@WAX2011", 1, pass.lookup(#BatchQtyToPick), extendedTypeNum(Qty), '', 0, false)];
        #        ret += [this.buildControl(#RFText, #BatchQtyPicked, "@WAX2011", 1, pass.lookup(#BatchQtyPicked), extendedTypeNum(Qty), '', 0, false)];
        #    }
        #
        #    ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, '', extendedTypeNum(InventBatchId), '', 0)];
        #
        #    ret = this.addOkButton(ret);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildGetFullQty
        #container buildGetFullQty(container _con, str _extraText = '')
        #{
        #    container               ret = _con;
        #    str                     finalLabel = _extraText ? _extraText : "@WAX727";     // Enter a Quantity
        #    UnitOfMeasureSymbol     inventUnit;
        #
        #    inventUnit = InventTableModule::find(workLine.ItemId, ModuleInventPurchSales::Invent).UnitId;
        #
        #    ret += [this.buildControl(#RFLabel, #Enter, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    ret += [this.buildControl(#RFText, #FullQty, "@WAX1327", 1, pass.lookupStr(#FullQty), #WHSRFUndefinedDataType, '', 0)];
        #    ret += [this.buildControl(#RFLabel, #UOM, inventUnit, 0, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    ret += [this.buildControl(#RFLabel, #RFQtyLabel, strFmt("@WAX2611", workLine.InventQtyRemain, inventUnit), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildGetItemId
        #container buildGetItemId(container _con, str _extraText = '')
        #{
        #    container           ret = _con;
        #    str                 finalLabel = _extraText ? _extraText : "@WAX720";     // Enter an ItemId
        #    InventTable         inventTable;
        #
        #    inventTable = InventTable::find(pass.lookupStr(#ItemId));
        #
        #    ret += [this.buildControl(#RFLabel, #Enter, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    ret += [this.buildControl(#RFText, #ItemId, "@SYS111673", 1, pass.lookupStr(#ItemId), extendedTypeNum(ItemId), '', 0)];
        #
        #    ret = this.buildProductDimensionsText(ret, inventTable.ItemId, true, true, true);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildGetLicensePlate
        #container buildGetLicensePlate(container _con, str _extraText = '', WHSLicensePlateId _licensePlateId = '')
        #{
        #    container   ret = _con;
        #    str         finalLabel = _extraText ? _extraText : "@WAX722";     // Scan a License Plate
        #    ;
        #
        #    ret += [this.buildControl(#RFLabel, #Scan, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX359", 1, _licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0)];
        #    ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildGetLocation
        #container buildGetLocation(container        _con,
        #                           str              _extraText = '',
        #                           WMSLocationId    _location = '')
        #{
        #    container   ret = _con;
        #    str         finalLabel = _extraText ? _extraText : "@WAX723";     // Scan a Location
        #    ;
        #
        #    ret += [this.buildControl(#RFLabel, #Scan, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    ret += [this.buildControl(#RFText, #WMSLocationId, "@SYS80395", 1, _location, extendedTypeNum(WMSLocationId), '', 0)];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildGetPotency
        #/// <summary>
        #///     Bulids the batch potency control.
        #/// </summary>
        #/// <param name="_con">
        #///     The RF container variable.
        #/// </param>
        #/// <param name="_inventBatchId">
        #///     The inventory batch ID specified on the purchase order line.
        #/// </param>
        #/// <param name="_includeGroupLabel">
        #///     Boolean value indicating whether the group label must be included.
        #/// </param>
        #/// <returns>
        #///     The updated RF container variable.
        #/// </returns>
        #protected container buildGetPotency(
        #    container       _con,
        #    InventBatchId   _inventBatchId,
        #    boolean         _includeGroupLabel = true)
        #{
        #    container           ret = _con;
        #    ItemId              itemId;
        #    InventTable         inventTable;
        #    PdsBatchAttribValue defaultValue;
        #    InventBatchId       batchId;
        #    boolean             enabled;
        #
        #
        #    itemId = pass.lookupStr(#ItemId);
        #
        #    if (this.capturePotency(itemId))
        #    {
        #        inventTable = InventTable::find(itemId);
        #
        #        pass.insert(#BaseAttributeId, inventTable.pdsBaseAttributeId);
        #
        #        if (pass.exists(#VendBatchInfoEntered))
        #        {
        #            defaultValue = pass.lookupStr(#Potency);
        #        }
        #        else
        #        {
        #            if (_inventBatchId)
        #            {
        #                batchId = _inventBatchId;
        #            }
        #            else
        #            {
        #                batchId = this.getInventBatchId();
        #            }
        #
        #            if (InventBatch::exist(itemId, batchId))
        #            {
        #                defaultValue = PdsBatchAttributes::find(itemId, batchId, inventTable.pdsBaseAttributeId).PdsBatchAttribValue;
        #            }
        #            else
        #            {
        #                defaultValue = WHSInventBatchReceiptDetails::find(pass.lookupStr(#ReceiptId), itemId, batchId).PdsPotencyBaseValue;
        #            }
        #        }
        #        enabled = (!defaultValue);
        #
        #        if (_includeGroupLabel)
        #        {
        #            ret += [this.buildControl(#RFLabel, #PotencyRFLabel, "@PSC61", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #        }
        #
        #        ret += [this.buildControl(#RFText, #Potency, inventTable.pdsBaseAttributeId, 1, defaultValue, extendedTypeNum(PDSBaseAttributeId), '', 0, enabled)];
        #    }
        #
        #    return ret;
        #}
        #
        #
      ENDSOURCE
      SOURCE #buildGetProdId
        #container buildGetProdId(container _con, str _extraText = '')
        #{
        #    container   ret = _con;
        #    str         finalLabel = _extraText ? _extraText : "@WAX726";     // Scan a Prod Id
        #    ;
        #
        #    ret += [this.buildControl(#RFLabel, #Scan, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    ret += [this.buildControl(#RFText, #ProdId, "@WAX725", 1, '', extendedTypeNum(ProdId), '', 0)];
        #    ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildGetVendBatchDetails
        #/// <summary>
        #///     Builds the RF screen to capture vendor batch information.
        #/// </summary>
        #/// <param name="_con">
        #///     The container to store RF values.
        #/// </param>
        #/// <returns>
        #///     The updated RF container variable.
        #/// </returns>
        #protected container buildGetVendBatchDetails(container _con)
        #{
        #    container   ret = _con;
        #    str         elements;
        #    str         dateFormat = WHSParameters::getDateFormat();
        #    boolean     useVendExpDateEditable;
        #
        #    useVendExpDateEditable = InventTable::find(pass.lookup(#ItemId)).isShelfLifeItem();
        #
        #    elements = this.buildNoYesCombobox();
        #
        #    ret += [this.buildControl(#RFLabel, #VendBatchInfo, "@SYS345080", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookup(#ItemId), extendedTypeNum(ItemId), '', 0, false)];
        #    ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, pass.lookup(#BatchId), extendedTypeNum(InventBatchId), '', 0, false)];
        #
        #    ret += [this.buildControl(#RFText, #VendBatchDate, strFmt("@WAX5517", dateFormat), 1, pass.lookup(#VendBatchDate), extendedTypeNum(PdsVendBatchDate), '', 0)];
        #    ret += [this.buildControl(#RFCombobox, #UseVendBatchDate, "@PRO2223", 1, elements, #WHSRFUndefinedDataType, '', 0, true, pass.lookup(#UseVendBatchDate))];
        #
        #    ret += [this.buildControl(#RFText, #VendExpDate, strFmt("@WAX5518", dateFormat), 1, pass.lookup(#VendExpDate), extendedTypeNum(PdsVendExpiryDate), '', 0)];
        #
        #    if (useVendExpDateEditable)
        #    {
        #        ret += [this.buildControl(#RFCombobox, #UseVendExpDate, "@PDS1343", 1, elements, #WHSRFUndefinedDataType, '', 0, true, pass.lookup(#UseVendExpDate))];
        #    }
        #    else
        #    {
        #        ret += [this.buildControl(#RFCombobox, #UseVendExpDate, "@PDS1343", 1, elements, #WHSRFUndefinedDataType, '', 0, false, enum2str(NoYes::No))];
        #
        #        pass.insert(#UseVendExpDate, enum2str(NoYes::No));
        #    }
        #
        #    ret += [this.buildControl(#RFText, #CountryOfOrigin1, "@PDS1345", 1, pass.lookup(#CountryOfOrigin1), extendedTypeNum(PdsCountryOfOrigin1), '', 0)];
        #    ret += [this.buildControl(#RFText, #CountryOfOrigin2, "@PDS1347", 1, pass.lookup(#CountryOfOrigin2), extendedTypeNum(PdsCountryOfOrigin2), '', 0)];
        #
        #    ret += [this.buildControl(#RFText, #VendBatchId, "@PDS1349", 1, pass.lookup(#VendBatchId), extendedTypeNum(PdsVendBatchId), '', 0)];
        #
        #    ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #    ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildGetWorkId
        #container buildGetWorkId(container _con, str _extraText = '')
        #{
        #    container   ret = _con;
        #    str         finalLabel = _extraText ? _extraText : "@WAX729";     // Scan a Work Id
        #    ;
        #
        #    ret += [this.buildControl(#RFLabel, #Scan, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    ret += [this.buildControl(#RFText, #WorkId, "@WAX273", 1, '', extendedTypeNum(WHSWorkId), '', 0)];
        #    ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildGetWorkIdLicensePlateId
        #container buildGetWorkIdLicensePlateId(container _con, str _extraText = '')
        #{
        #    container   ret = _con;
        #    str         finalLabel = _extraText ? _extraText : "@WAX1056";     // Scan a Work Id / License Plate Id
        #    ;
        #
        #    ret += [this.buildControl(#RFLabel, #Scan, finalLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    ret += [this.buildControl(#RFText, #WHSWorkLicensePlateId, "@WAX33", 1, '', extendedTypeNum(WHSLicensePlateId), '', 0)];
        #    ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #    if (!pass.exists(#AddCancel))
        #    {
        #        ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildGroupedPutaway
        #container buildGroupedPutaway(container _con)
        #{
        #    WHSWorkExecute      workExecute = new WHSWorkExecute();
        #    container           ret = _con;
        #    WHSRFAutoConfirm    autoConfirm;
        #    WHSWorkGrouping     workGrouping;
        #    WHSWorkLine         groupWorkLine;
        #    Qty                 qty;
        #    InventQty           inventQty;
        #    UnitOfMeasureSymbol workUnitId;
        #    UnitOfMeasureSymbol inventUnitId;
        #    ItemId              itemId;
        #    boolean             multipleItem;
        #    boolean             multipleUOM;
        #    boolean             multipleInventUOM;
        #    InventTableModule   inventTableModule;
        #    WHSRFDescription1   description1;
        #    WHSRFDescription2   description2;
        #    WHSLicensePlateId   groupLicensePlateId;
        #
        #    void setMultipleValues()
        #    {
        #        inventTableModule = InventTableModule::find(groupWorkLine.ItemId, ModuleInventPurchSales::Invent);
        #
        #        if ((itemId && itemId != groupWorkLine.ItemId) || !groupWorkLine.ItemId)
        #        {
        #            multipleItem = true;
        #        }
        #
        #        if ((workUnitId && workUnitId != groupWorkLine.UnitId) || !groupWorkLine.UnitId)
        #        {
        #            multipleUOM = true;
        #        }
        #
        #        if ((inventUnitId && inventUnitId != inventTableModule.UnitId) || !inventTableModule.UnitId)
        #        {
        #            multipleInventUOM = true;
        #        }
        #
        #        qty += groupWorkLine.QtyWork;
        #        inventQty += groupWorkLine.InventQtyWork;
        #
        #        itemId = groupWorkLine.ItemId;
        #        workUnitId = groupWorkLine.UnitId;
        #        inventUnitId = inventTableModule.UnitId;
        #    }
        #
        #    if (pass.exists(#WorkGroupingId) && pass.lookup(#WorkGroupingId) != '' && WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem)).GroupPutaway)
        #    {
        #        while select WorkId from workGrouping
        #            where workGrouping.WorkGroupingId == pass.lookup(#WorkGroupingId)
        #        {
        #            groupWorkLine = workExecute.getFirstOpenLine(workGrouping.WorkId, pass.lookup(#UserId));
        #
        #            setMultipleValues();
        #        }
        #    }
        #    else
        #    {
        #        // If Grouping Id does not exist must be in a multi-put scenario.
        #        while select groupWorkLine
        #            where groupWorkLine.WorkId  == workLine.WorkId
        #            &&    groupWorkLine.LineNum >= workLine.LineNum
        #        {
        #            setMultipleValues();
        #
        #            if (!groupLicensePlateId)
        #            {
        #                groupLicensePlateId = workTable.TargetLicensePlateId;
        #            }
        #        }
        #    }
        #
        #    ret += [this.buildControl(#RFLabel, 'Put', strFmt("@WAX1270", workTable.WorkTransType), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];
        #
        #    select firstonly autoConfirm
        #            where autoConfirm.MenuItemName      == pass.lookup(#MenuItem)   &&
        #                  autoConfirm.WorkType          == WHSWorkType::Put         &&
        #                  autoConfirm.LocVerification   == NoYes::Yes;
        #
        #    if (autoConfirm && !pass.exists(#GroupPutaway))
        #    {
        #        if (WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId).CheckText)
        #        {
        #            ret += [this.buildControl(#RFText, #CheckDigit, "@WAX1197", 1, '', extendedTypeNum(WMSCheckText), '', 0)];
        #        }
        #        else if (pass.exists(#SystemPopulated))
        #        {
        #            if ((!pass.exists(#PrevStep) || pass.lookup(#PrevStep) != WHSWorkExecuteDisplay::num2StrDisplay(#OverrideStep2)) && !pass.exists(#GroupPutawayConfirm))
        #            {
        #                ret += [this.buildControl(#RFText, #LocVerification, "@WAX1196", 1, '', extendedTypeNum(WMSLocationId), '', 0)];
        #            }
        #        }
        #    }
        #
        #    if (groupLicensePlateId)
        #    {
        #        ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, groupLicensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        #    }
        #
        #    // Clear out UOM values if grouped work units do not match
        #    if (multipleUOM)
        #    {
        #        workUnitId = '';
        #    }
        #
        #    if (multipleInventUOM)
        #    {
        #        inventUnitId = '';
        #    }
        #
        #    if (multipleItem)
        #    {
        #        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, "@WAX402", extendedTypeNum(ItemId), '', 0, false)];
        #    }
        #    else
        #    {
        #        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, itemId, extendedTypeNum(ItemId), '', 0, false)];
        #    }
        #
        #    ret += [this.buildControl(#RFLabel, #RFQtyLabel, strFmt("@WAX1283", qty, workUnitId, inventQty, inventUnitId, ';\t'), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    autoConfirm.clear();
        #
        #    select firstonly autoConfirm
        #        where autoConfirm.MenuItemName  == pass.lookup(#MenuItem)   &&
        #              autoConfirm.WorkType      == WHSWorkType::Put         &&
        #              autoConfirm.VerifyQty     == NoYes::Yes;
        #
        #    if (autoConfirm && !pass.exists(#GroupPutaway))
        #    {
        #        ret += [this.buildControl(#RFText, #QtyVerification, "@SYS105177", 1, '', extendedTypeNum(Qty), '', 0)];
        #        ret += [this.buildControl(#RFLabel, #QtyVerifyUOM, workUnitId, 0, '', #WHSRFUndefinedDataType, '', 0, false)];
        #    }
        #
        #    if (!multipleItem)
        #    {
        #        description1    = WHSInventTable::find(itemId).rfDescription1;
        #        description2    = WHSInventTable::find(itemId).rfDescription2;
        #
        #        if (description1)
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', description1), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #        else
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', InventTable::find(workLine.ItemId).defaultProductName()), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #
        #        if (description2)
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", description2), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #    }
        #
        #    pass.insert(#LicensePlateId, workTable.TargetLicensePlateId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildInventoryStatus
        #container buildInventoryStatus(container    _con,
        #                               str          _label = '',
        #                               boolean      _showRemove = false,
        #                               boolean      _showBlank = false,
        #                               boolean      _showOK = true,
        #                               str          _selected = '',
        #                               boolean      _enabled = true)
        #{
        #    WHSInventStatus     inventStatus;
        #    container           ret = _con;
        #    boolean             first = true;
        #    str                 elements;
        #    str                 label = _label ? _label : "@WAX357";      // Inventory Status
        #    ;
        #
        #    if (_showBlank)
        #    {
        #        elements = '||';
        #    }
        #
        #    while select inventStatus
        #    {
        #        if (first)
        #        {
        #            elements += inventStatus.Name;
        #            first = false;
        #        }
        #        else
        #        {
        #            elements = elements + '||' + inventStatus.Name;
        #        }
        #    }
        #
        #    ret += [this.buildControl(#RFCombobox, #InventoryStatus, label, 1, elements, #WHSRFUndefinedDataType, '', 0, _enabled, _selected)];
        #
        #    if (_showRemove)
        #    {
        #        ret += [this.buildControl(#RFButton, "@SYS26394", "@WAX879", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #
        #    if (_showOK)
        #    {
        #        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildLocationListFromSet
        #str buildLocationListFromSet(Set _locations)
        #{
        #    SetEnumerator   se = new SetEnumerator();
        #    str             current;
        #    str             ret;
        #
        #    if (_locations)
        #    {
        #        se = _locations.getEnumerator();
        #
        #        while (se.moveNext())
        #        {
        #            current = se.current();
        #
        #            if (!ret)
        #            {
        #                ret = current;
        #            }
        #            else
        #            {
        #                ret = ret + ',' + current;
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildLocationListFromStr
        #Set buildLocationListFromStr(str _locations)
        #{
        #    ListEnumerator  le = new ListEnumerator();
        #    List            locations;
        #    str             current;
        #    Set             ret = new Set(Types::String);
        #
        #    if (_locations)
        #    {
        #        locations = strSplit(_locations, ',');
        #
        #        le = locations.getEnumerator();
        #
        #        while (le.moveNext())
        #        {
        #            current = le.current();
        #            ret.add(current);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildNextDimensionCaptureControl
        #/// <summary>
        #/// Builds the next input control for inventory dimension capture if needed.
        #/// </summary>
        #/// <param name="_con">
        #/// Current container that represents the currently build RF screen.
        #/// </param>
        #/// <param name="_inventDim">
        #/// The inventDim holding values predetermined by the work.
        #/// </param>
        #/// <param name="_itemId">
        #/// The Id of the item which determines the reservation hierarchy, thus, determining the next dimensions contorl.
        #/// </param>
        #/// <param name="_qty">
        #/// The qty remaining to be picked.
        #/// </param>
        #/// <param name="_updatePass">
        #/// A boolean which determines how we are updating the global pass. If building a new dim control we must prompt the user again.
        #/// </param>
        #/// <param name="_assignSerial">
        #/// A boolean which determines if we should add serial control, as item is serial enabled and serial number is capture at picking.
        #/// </param>
        #/// <returns>
        #/// A container that represents the currently build RF screen including any controls built in this method.
        #/// </returns>
        #protected container buildNextDimensionCaptureControl(
        #    container   _con,
        #    InventDim   _inventDim,
        #    ItemId      _itemId,
        #    InventQty   _qty,
        #    boolean     _updatePass = true,
        #    boolean     _assignSerial = false)
        #{
        #    ListEnumerator                      enumerator;
        #    container                           ret = _con;
        #    InventDim                           inventDim = _inventDim;
        #    InventDim                           tmpInventDim;
        #    FieldId                             fieldId;
        #    FieldName                           fieldName;
        #    DictField                           dictField;
        #    boolean                             prompt;
        #    WHSReservationHierarchyProvider     reservationHierarchyProvider;
        #    WHSReservationHierarchyElementData  elementData;
        #    InventTable                         inventTable;
        #
        #    // If item is not specified, no need to evaluate and display dim controls
        #    if (!_itemId)
        #    {
        #        return ret;
        #    }
        #
        #    if (pass.exists(#LicensePlateId))
        #    {
        #        inventDim.LicensePlateId = pass.lookup(#LicensePlateId);
        #    }
        #
        #    // Get invent table for current item id
        #    inventTable = InventTable::find(_itemId);
        #
        #    // Get List
        #    reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();
        #    enumerator = reservationHierarchyProvider.getDimListBelowLicensePlate(
        #                        inventTable,
        #                        WHSReservationHierarchySortOrder::TopDown)
        #                    .getEnumerator();
        #
        #    while (enumerator.moveNext())
        #    {
        #        elementData = enumerator.current();
        #        fieldId = elementData.parmDimensionFieldId();
        #        fieldName = fieldId2name(inventDim.TableId, fieldId);
        #        dictField = new DictField(tableNum(InventDim), fieldId);
        #
        #        if (pass.exists(fieldName) && pass.hasValue(fieldName))
        #        {
        #            inventDim.(fieldId) = pass.lookup(fieldName);
        #            ret += [this.buildControl(#RFText, fieldName, dictField.label(), 1, pass.lookupStr(fieldName), dictField.typeId(), '', 0)];
        #            continue;
        #        }
        #
        #        // Call method to determine if are demand qty is >= what is on the dimensions set
        #        if (!_assignSerial && !this.isOnHandGreaterThanDemand(inventDim, _itemId, _qty))
        #        {
        #            break;
        #        }
        #
        #        // Check to see if we are allowed to pick a batch negative, if so prompt for desired batch
        #        if (this.promptForNegativeBatch(fieldId, inventDim, _itemId))
        #        {
        #            if (!pass.exists(#BatchId) || !pass.hasValue(#BatchId))
        #            {
        #                pass.insert(#BatchId, this.findDefaultBatch(inventTable, inventDim.wmsLocation()));
        #            }
        #
        #            ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, pass.lookupStr(#BatchId), extendedTypeNum(InventBatchId), '', 0)];
        #
        #            break;
        #        }
        #
        #        // Call a method used for defaulting the dim field if there is only one available
        #        if (!_assignSerial)
        #        {
        #            [tmpInventDim, prompt] = this.getDefaultDimValue(inventDim, fieldId, _itemId);
        #            if (!prompt)
        #            {
        #                inventDim.(fieldId) = tmpInventDim.(fieldId);
        #                continue;
        #            }
        #        }
        #
        #        // Ask for current dimension
        #        // For Serial id, we might have multiple so we want to keep the counter
        #        if (fieldId == fieldNum(InventDim, InventSerialId) && _assignSerial)
        #        {
        #            ret += [this.buildControl(#RFLabel,
        #                #SerialCounter,
        #                strFmt("@WAX3121", pass.lookup(#SerialCounter), pass.lookupNum(#SerialQty), inventTable.inventUnitId()),
        #                1, '', #WHSRFUndefinedDataType, '', 0)];
        #        }
        #
        #        ret += [this.buildControl(#RFText, fieldName, dictField.label(), 1, pass.lookupStr(fieldName), dictField.typeId(), '', 0)];
        #
        #        if (!_updatePass)
        #        {
        #            pass.insert(#DimPrompt, 1);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildNoYesCombobox
        #/// <summary>
        #///     Builds a pipe-delimited string containing no, yes, and blank values.
        #/// </summary>
        #/// <returns>
        #///     Returns a pipe-delimited string containing no, yes, and blank values.
        #/// </returns>
        #protected str buildNoYesCombobox()
        #{
        #    return '||' + enum2str(NoYes::No) + '||' + enum2str(NoYes::Yes);
        #}
      ENDSOURCE
      SOURCE #buildPick
        #container buildPick(
        #    container _con,
        #    str       _extraText  = '',
        #    boolean   _updatePass = true)
        #{
        #    container           ret = _con;
        #    WMSLocation         location;
        #    WHSLicensePlateId   licensePlateId;
        #    WHSRFDescription1   description1;
        #    WHSRFDescription2   description2;
        #    InventDim           inventDim;
        #    str                 qty;
        #    str                 inventQty;
        #    UnitOfMeasureSymbol uom;
        #    UnitOfMeasureSymbol inventUOM;
        #    WHSRFAutoConfirm    autoConfirm;
        #    InventTable         inventTable;
        #    WHSLicensePlate     licensePlate;
        #    boolean             licensePlateControlled;
        #
        #    description1    = WHSInventTable::find(workLine.ItemId).rfDescription1;
        #    description2    = WHSInventTable::find(workLine.ItemId).rfDescription2;
        #    inventDim       = InventDim::find(workLine.InventDimId);
        #    qty             = WHSWorkExecuteDisplay::num2StrDisplay(workLine.QtyRemain);
        #    inventQty       = WHSWorkExecuteDisplay::num2StrDisplay(workLine.InventQtyRemain);
        #    uom             = workLine.UnitId;
        #    inventUOM       = InventTableModule::find(workLine.ItemId, ModuleInventPurchSales::Invent).UnitId;
        #    licensePlateId  = workTable.TargetLicensePlateId;
        #    inventTable     = InventTable::find(workLine.ItemId);
        #
        #    if (workLine.wmsLocationId)
        #    {
        #        location = WMSLocation::find(workLine.wmsLocationId, pass.lookup(#InventLocationId));
        #        licensePlateControlled = location.whsLocationIsLPControlled();
        #        pass.insert(#SystemPopulated, 1);
        #    }
        #
        #    if (mode == WHSWorkExecuteMode::SystemGrouping)
        #    {
        #        ret += [this.buildControl(#RFLabel, #GroupingLabel, strFmt("@WAX2394", pass.lookup(#GroupingWorkNum), pass.lookup(#GroupingWorkTotal)), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #    else if (mode == WHSWorkExecuteMode::UserGrouping)
        #    {
        #        ret += [this.buildControl(#RFLabel, #GroupingLabel, strFmt("@WAX2393", pass.lookup(#GroupingWorkNum)), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #
        #    ret += [this.buildControl(#RFLabel, #RFPick, this.getPickHeaderLabel(enum2str(workTable.WorkTransType)), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];
        #
        #    if (pass.exists(#MenuItem))
        #    {
        #        select firstonly autoConfirm
        #            where autoConfirm.MenuItemName      == pass.lookup(#MenuItem)   &&
        #                  autoConfirm.WorkType          == WHSWorkType::Pick        &&
        #                  autoConfirm.LocVerification   == NoYes::Yes;
        #
        #        if (autoConfirm)
        #        {
        #            if (location.CheckText)
        #            {
        #                ret += [this.buildControl(#RFText, #CheckDigit, "@WAX1197", 1, pass.lookupStr(#CheckDigit), extendedTypeNum(WMSCheckText), '', 0)];
        #            }
        #            else if (pass.exists(#SystemPopulated))
        #            {
        #                ret += [this.buildControl(#RFText, #LocVerification, "@WAX1196", 1, pass.lookupStr(#LocVerification), extendedTypeNum(WMSLocationId), '', 0)];
        #            }
        #        }
        #    }
        #
        #    if (   mode != WHSWorkExecuteMode::ReportAsFinishedAndLocate
        #        && mode != WHSWorkExecuteMode::KanbanPutAndLocate)
        #    {
        #        if (licensePlateId && !workLine.AskForNewLicensePlate)
        #        {
        #            ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        #
        #            if ((mode == WHSWorkExecuteMode::UserGrouping       ||
        #                 mode == WHSWorkExecuteMode::SystemGrouping)    &&
        #                 _updatePass)
        #            {
        #                pass.insert(#LicensePlateId, workTable.TargetLicensePlateId);
        #            }
        #        }
        #        if (licensePlateId                          &&
        #            workLine.isFirstWorkLine()              &&
        #            mode != WHSWorkExecuteMode::PickPack)
        #        {
        #            if (!pass.hasValue(#LicensePlateId))
        #            {
        #                pass.insert(#LicensePlateId, workTable.TargetLicensePlateId);
        #            }
        #            if (licensePlateControlled
        #            &&  ((workLine.InventQtyRemain != 0
        #            &&    workLine.InventQtyRemain != workLine.InventQtyWork)
        #            ||   WHSWorkTable::isPickCompleted(workLine.WorkId)))
        #            {
        #                if (_updatePass)
        #                {
        #                    ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, '', extendedTypeNum(WHSLicensePlateId), '', 0)];
        #                }
        #                else
        #                {
        #                    ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookupStr(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0)];
        #                }
        #            }
        #        }
        #        else if (licensePlateControlled && !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum) && !workLine.AskForNewLicensePlate)
        #        {
        #            if (_updatePass)
        #            {
        #                ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, '', extendedTypeNum(WHSLicensePlateId), '', 0)];
        #            }
        #            else
        #            {
        #                ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookupStr(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0)];
        #            }
        #        }
        #    }
        #    else
        #    {
        #        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0)];
        #    }
        #
        #    if (!licensePlateId && !licensePlateControlled)
        #    {
        #        if ((mode   == WHSWorkExecuteMode::UserGrouping     ||
        #            mode    == WHSWorkExecuteMode::SystemGrouping)  &&
        #            pass.exists(#LicensePlateId))
        #        {
        #            pass.remove(#LicensePlateId);
        #        }
        #
        #        if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP)
        #        {
        #            ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, WHSLicensePlate::generateLicensePlateId(workLine.ItemId, workLine.UnitId), extendedTypeNum(WHSLicensePlateId), '', 0)];
        #        }
        #        else
        #        {
        #            ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, '', extendedTypeNum(WHSLicensePlateId), '', 0)];
        #        }
        #    }
        #    else if (!licensePlateControlled && pass.exists(#LicensePlateId))
        #    {
        #        pass.remove(#LicensePlateId);
        #    }
        #
        #    if (workLine.AskForNewLicensePlate)
        #    {
        #        if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP)
        #        {
        #            ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, WHSLicensePlate::generateLicensePlateId(workLine.ItemId, workLine.UnitId), extendedTypeNum(WHSLicensePlateId), '', 0)];
        #        }
        #        else
        #        {
        #            ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, '', extendedTypeNum(WHSLicensePlateId), '', 0)];
        #        }
        #
        #        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookupStr(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, 0)];
        #    }
        #
        #    if (pass.exists(#LicensePlateId))
        #    {
        #        if (!pass.exists(#DimTrackingDelay))
        #        {
        #            licensePlate = WHSLicensePlate::find(pass.lookup(#LicensePlateId));
        #        }
        #        else
        #        {
        #            pass.remove(#DimTrackingDelay);
        #        }
        #    }
        #
        #    if (!workLine.ItemId)
        #    {
        #        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, "@SYS78137", extendedTypeNum(ItemId), '', 0, false)];
        #    }
        #    else
        #    {
        #        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, workLine.ItemId, extendedTypeNum(ItemId), '', 0, false)];
        #    }
        #
        #    if (workLine.QtyRemain)
        #    {
        #        ret += [this.buildControl(#RFLabel, #RFQtyLabel, strFmt("@WAX1283", qty, uom, inventQty, inventUOM, ';\t'), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #        if (pass.exists(#MenuItem))
        #        {
        #            select firstonly autoConfirm
        #            where autoConfirm.MenuItemName  == pass.lookup(#MenuItem)   &&
        #                  autoConfirm.WorkType      == WHSWorkType::Pick        &&
        #                  autoConfirm.VerifyQty     == NoYes::Yes;
        #
        #            if (autoConfirm)
        #            {
        #                ret += [this.buildControl(#RFText, #QtyVerification, "@SYS105177", 1, '', extendedTypeNum(Qty), '', 0)];
        #                ret += [this.buildControl(#RFLabel, #QtyVerifyUOM, uom, 0, '', #WHSRFUndefinedDataType, '', 0, false)];
        #            }
        #        }
        #    }
        #
        #    if (workLine.ItemId)
        #    {
        #        if (description1)
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', description1), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #        else
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', InventTable::find(workLine.ItemId).defaultProductName()), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #
        #        if (description2)
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt('\t        %1', description2), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #    }
        #
        #    // Build label controls for all dimensions specified above location
        #    ret = this.buildAboveLocationDimensions(ret, workLine.inventDim(), workLine.ItemId);
        #
        #    // Build control to capture next dimension
        #    // No need to prompt for dimension if raw material picking in a license plate controlled location since full LP qty is picked
        #    if (pass.lookupStr(#SkipSerialValidate) != #AssignSerialComplete // if we have been through the serial assignment, we don't need to prompt for dimensions
        #    && ((licensePlateControlled
        #    &&   licensePlate
        #    &&   workTable.WorkTransType != WHSWorkTransType::ProdPick
        #    &&   workTable.WorkTransType != WHSWorkTransType::KanbanPick)
        #    ||   !licensePlateControlled))
        #    {
        #        ret = this.buildNextDimensionCaptureControl(ret, workLine.inventDimWithLocation(), workLine.ItemId, workLine.InventQtyRemain, _updatePass);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildPORecTrackingDimensions
        #protected container buildPORecTrackingDimensions(
        #    container   _con,
        #    ItemId      _itemId,
        #    Qty         _defaultQty)
        #{
        #    container           ret = _con;
        #    WHSInventTable      whsInventTable;
        #    ListEnumerator      le;
        #    str                 qtyString;
        #    InventDim           purchLineInventDim;
        #    InventBatchId       batchId;
        #
        #    whsInventTable = WHSInventTable::find(_itemId);
        #    qtyString = WHSWorkExecuteDisplay::num2StrDisplay(_defaultQty);
        #    purchLineInventDim = PurchLine::find(pass.lookup(#PONum), pass.lookupInt64(#POLineNum)).inventDim();
        #    batchId = purchLineInventDim.InventBatchId;
        #
        #    ret += [this.buildControl(#RFLabel, "@WAX5546", "@WAX5546", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookup(#ItemId), extendedTypeNum(ItemId), '', 0, false)];
        #
        #    if (whsInventTable.rfDescription1)
        #    {
        #        ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", whsInventTable.rfDescription1), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #    }
        #    else
        #    {
        #        ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(whsInventTable.ItemId).defaultProductName()), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #    }
        #
        #    if (whsInventTable.rfDescription2)
        #    {
        #        ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", whsInventTable.rfDescription2), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #    }
        #
        #    ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookup(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        #
        #    le = InventDimGroupSetup::newDimensionGroups(0, 0, InventTable::find(_itemId).trackingDimensionGroup()).activeFields().getEnumerator();
        #
        #    while (le.moveNext())
        #    {
        #        switch (le.current())
        #        {
        #            case fieldNum(InventDim, InventBatchId):
        #                // If vendor batch details have been entered, all fields should already be populated within the pass.
        #                if (pass.exists(#VendBatchInfoEntered))
        #                {
        #                    ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, pass.lookup(#BatchId), extendedTypeNum(InventBatchId), '', 0, false)];
        #                }
        #                else if (batchId)
        #                {
        #                    ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, batchId, extendedTypeNum(InventBatchId), '', 0, false)];
        #                }
        #                else if (pass.exists(#SessionBatchId) && pass.lookup(#SessionBatchId))
        #                {
        #                    ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, pass.lookup(#SessionBatchId), extendedTypeNum(InventBatchId), '', 0)];
        #                }
        #                else
        #                {
        #                    ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, '', extendedTypeNum(InventBatchId), '', 0)];
        #                }
        #
        #                // Build the batch expiration date control.
        #                ret = this.buildBatchExpDate(ret);
        #                break;
        #
        #            case fieldNum(InventDim, InventSerialId):
        #                if (WHSInventTable::captureSerial(_itemId) == WHSRFWhenToCapture::Receiving)
        #                {
        #                    ret += [this.buildControl(#RFText, #SerialId, "@WAX1614", 1, '', extendedTypeNum(InventSerialId), '', 0, (purchLineInventDim.InventSerialId == ''))];
        #
        #                    if (EcoResTrackingDimensionGroup::find(InventTable::find(_itemId).trackingDimensionGroup()).IsSerialNumberControlEnabled)
        #                    {
        #                        qtyString = WHSWorkExecuteDisplay::num2StrDisplay(1);
        #                    }
        #
        #                }
        #                break;
        #
        #            default:
        #                // If any dimensions are specified on the purch line, default the value and make the control non editable.
        #                if (purchLineInventDim.(le.current()))
        #                {
        #                    ret += [this.buildControlForTableField(tableNum(InventDim),
        #                                                           le.current(),
        #                                                           fieldId2name(tableNum(InventDim), le.current()),
        #                                                           1,
        #                                                           purchLineInventDim.(le.current()),
        #                                                           false)];
        #                }
        #                else
        #                {
        #                    ret += [this.buildControlForTableField(tableNum(InventDim),
        #                                                           le.current(),
        #                                                           fieldId2name(tableNum(InventDim), le.current()),
        #                                                           1,
        #                                                           '',
        #                                                           true)];
        #                }
        #                break;
        #        }
        #    }
        #
        #    ret += [this.buildControl(#RFText, #DimQty, "@SYS105177", 1, qtyString, extendedTypeNum(Qty), '', 0)];
        #    ret = this.buildTrackingDimReceiptUOM(ret, '', false, false, pass.lookupStr(#DimUOM));
        #
        #    // Build the batch disposition control
        #    ret = this.buildBatchDisposition(ret);
        #
        #    // Build potency control
        #    ret = this.buildGetPotency(ret, batchId);
        #
        #    ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #    ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildProductDimensionsFromInventDim
        #/// <summary>
        #/// Builds RF text controls for product dimensions based off an inventory dimension record.
        #/// </summary>
        #/// <param name="_con">
        #/// The current RF container we are adding text controls to.
        #/// </param>
        #/// <param name="_itemId">
        #/// The item whose product dimensions we are adding controls for.
        #/// </param>
        #/// <param name="_inventDim">
        #/// The inventory dimension record we are basing product dimension controls off of.
        #/// </param>
        #/// <param name="_enableControls">
        #/// Boolean to determine whether added text controls should be editable.
        #/// </param>
        #/// <returns>
        #/// An updated RF container which includes text controls for the item's product dimensions.
        #/// </returns>
        #protected container buildProductDimensionsFromInventDim(
        #    container   _con,
        #    ItemId      _itemId,
        #    InventDim   _inventDim,
        #    boolean     _enableControls = true)
        #{
        #    container       ret = _con;
        #    ListEnumerator  le;
        #
        #    le = InventDimGroupSetup::newItemIdProductDimensionsOnly(_itemId).activeFields().getEnumerator();
        #
        #    while (le.moveNext())
        #    {
        #        ret += [this.buildControlForTableField(tableNum(InventDim),
        #                                               le.current(),
        #                                               fieldId2name(tableNum(InventDim), le.current()),
        #                                               1,
        #                                               _inventDim.(le.current()),
        #                                               _enableControls)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildProductDimensionsText
        #/// <summary>
        #/// Builds RF text controls for active product dimensions.
        #/// </summary>
        #/// <param name="_con">
        #/// The current RF container we are adding text controls to.
        #/// </param>
        #/// <param name="_itemId">
        #/// The item whose product dimensions we are adding controls for.
        #/// </param>
        #/// <param name="_populate">
        #/// Boolean to determine whether to populate controls with current values in passthrough.
        #/// </param>
        #/// <param name="_enableControls">
        #/// Boolean to determine whether added text controls should be editable.
        #/// </param>
        #/// /// <param name="_insertPass">
        #/// Boolean to determine whether to add values to the passthrough if they don't exist.
        #/// </param>
        #/// <returns>
        #/// An updated RF container which includes text controls for the item's product dimensions.
        #/// </returns>
        #protected container buildProductDimensionsText(
        #    container   _con,
        #    ItemId      _itemId,
        #    boolean     _populate = false,
        #    boolean     _enableControls = true,
        #    boolean     _insertPass = false)
        #{
        #    container       ret = _con;
        #    ListEnumerator  le;
        #    FieldName       fieldName;
        #
        #    le = InventDimGroupSetup::newItemIdProductDimensionsOnly(_itemId).activeFields().getEnumerator();
        #
        #    while (le.moveNext())
        #    {
        #        fieldName = fieldId2name(tableNum(InventDim), le.current());
        #
        #        ret += [this.buildControlForTableField(tableNum(InventDim),
        #                                               le.current(),
        #                                               fieldName,
        #                                               1,
        #                                               _populate ? pass.lookupStr(fieldName) : '',
        #                                               _enableControls)];
        #
        #        if (_insertPass && !pass.exists(fieldName))
        #        {
        #            pass.insert(fieldName, '');
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildPut
        #container buildPut(container    _con,
        #                   str          _extraText = '')
        #{
        #    container           ret = _con;
        #    WHSLicensePlateId   licensePlateId;
        #    WHSLicensePlate     licensePlate;
        #    WHSRFDescription1   description1;
        #    WHSRFDescription2   description2;
        #    InventDim           inventDim;
        #    str                 qty;
        #    str                 inventQty;
        #    UnitOfMeasureSymbol uom;
        #    UnitOfMeasureSymbol inventUOM;
        #    WHSRFAutoConfirm    autoConfirm;
        #
        #    description1    = WHSInventTable::find(workLine.ItemId).rfDescription1;
        #    description2    = WHSInventTable::find(workLine.ItemId).rfDescription2;
        #    inventDim       = InventDim::find(workLine.InventDimId);
        #    qty             = WHSWorkExecuteDisplay::num2StrDisplay(workLine.QtyRemain);
        #    inventQty       = WHSWorkExecuteDisplay::num2StrDisplay(workLine.InventQtyRemain);
        #    uom             = workLine.UnitId;
        #    inventUOM       = InventTableModule::find(workLine.ItemId, ModuleInventPurchSales::Invent).UnitId;
        #
        #    if (workLine.wmsLocationId && !pass.exists(#UserPutLocation))
        #    {
        #        pass.insert(#SystemPopulated, 1);
        #    }
        #
        #    ret += [this.buildControl(#RFLabel, #RFPut, strFmt("@WAX1270", workTable.WorkTransType), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];
        #
        #    if (pass.exists(#MenuItem))
        #    {
        #        select firstonly autoConfirm
        #            where autoConfirm.MenuItemName      == pass.lookup(#MenuItem)   &&
        #                  autoConfirm.WorkType          == WHSWorkType::Put         &&
        #                  autoConfirm.LocVerification   == NoYes::Yes;
        #
        #        if (autoConfirm)
        #        {
        #            if (WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId).CheckText)
        #            {
        #                ret += [this.buildControl(#RFText, #CheckDigit, "@WAX1197", 1, '', extendedTypeNum(WMSCheckText), '', 0)];
        #            }
        #            else if (pass.exists(#SystemPopulated))
        #            {
        #                if ((!pass.exists(#PrevStep) || pass.lookup(#PrevStep) != WHSWorkExecuteDisplay::num2StrDisplay(#OverrideStep2)) && !pass.exists(#GroupPutawayConfirm))
        #                {
        #                    ret += [this.buildControl(#RFText, #LocVerification, "@WAX1196", 1, '', extendedTypeNum(WMSLocationId), '', 0)];
        #                }
        #            }
        #        }
        #    }
        #
        #    licensePlateId  = workTable.TargetLicensePlateId;
        #    licensePlate    = WHSLicensePlate::find(licensePlateId);
        #
        #    ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0, licensePlateId ? false : true)];
        #
        #    if (   workTable.WorkTransType != WHSWorkTransType::ProdPick
        #        && workTable.WorkTransType != WHSWorkTransType::KanbanPick
        #        && workLine.ItemId         != ''
        #        && WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId).whsLocationIsLPControlled()
        #        && licensePlate.getTotalQtyOnLicensePlate(licensePlateId) > workLine.InventQtyRemain)
        #    {
        #        ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, '', extendedTypeNum(WHSLicensePlateId), '', 0)];
        #    }
        #    else if (pass.exists(#TargetLicensePlateId) && pass.lookup(#TargetLicensePlateId) != workTable.TargetLicensePlateId)
        #    {
        #        pass.remove(#TargetLicensePlateId);
        #    }
        #
        #    if (!workLine.ItemId)
        #    {
        #        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, "@WAX402", extendedTypeNum(ItemId), '', 0, false)];
        #    }
        #    else
        #    {
        #        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, workLine.ItemId, extendedTypeNum(ItemId), '', 0, false)];
        #    }
        #
        #    if (workLine.QtyRemain)
        #    {
        #        ret += [this.buildControl(#RFLabel, #RFQtyLabel, strFmt("@WAX1283", qty, uom, inventQty, inventUOM, ';\t'), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #        if (pass.exists(#MenuItem))
        #        {
        #            select firstonly autoConfirm
        #            where autoConfirm.MenuItemName  == pass.lookup(#MenuItem)   &&
        #                  autoConfirm.WorkType      == WHSWorkType::Put         &&
        #                  autoConfirm.VerifyQty     == NoYes::Yes;
        #
        #            if (autoConfirm)
        #            {
        #                ret += [this.buildControl(#RFText, #QtyVerification, "@SYS105177", 1, '', extendedTypeNum(Qty), '', 0)];
        #                ret += [this.buildControl(#RFLabel, #QtyVerifyUOM, uom, 0, '', #WHSRFUndefinedDataType, '', 0, false)];
        #            }
        #        }
        #    }
        #
        #    if (workLine.ItemId)
        #    {
        #        if (description1)
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', description1), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #        else
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', InventTable::find(workLine.ItemId).defaultProductName()), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #
        #        if (description2)
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", description2), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #    }
        #
        #    // Build label controls for all dimensions specified above location
        #    ret = this.buildAboveLocationDimensions(ret, workLine.inventDim(), workLine.ItemId);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildReceivingExceptions
        #container buildReceivingExceptions(container _con, str _selected = '')
        #{
        #    WHSWorkException        exceptions;
        #    container               ret = _con;
        #    boolean                 first = true;
        #    str                     elements;
        #
        #    while select exceptions
        #        where exceptions.ExceptionType == WHSExceptionType::Receiving
        #    {
        #        if (first)
        #        {
        #            elements = exceptions.WorkExceptionDesc;
        #            first = false;
        #        }
        #        else
        #        {
        #            elements = elements + '||' + exceptions.WorkExceptionDesc;
        #        }
        #    }
        #
        #    ret += [this.buildControl(#RFCombobox, #WHSReceivingException, "@WAX494", 1, elements, #WHSRFUndefinedDataType, '', 0, true, _selected)];
        #    ret += [this.buildControl(#RFButton, #RFNextException, "@WAX718", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    ret += [this.buildControl(#RFButton, #RFDone, "@SYS112206", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildReceivingLicensePlateInfo
        #container buildReceivingLicensePlateInfo(container              _con,
        #                                         WHSLicensePlateId      _licensePlateId,
        #                                         WHSModule              _module)
        #{
        #    WHSUOMStructure         structure;
        #    WHSASNItem              asnItem;
        #    boolean                 hasVendor;
        #    boolean                 hasOrder;
        #    container               ret = _con;
        #    str                     itemInfo;
        #    int                     i;
        #
        #    ret += [this.buildControl(#RFLabel, int2str(i), strFmt("@WAX730", _licensePlateId), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    select firstonly RecId from structure
        #        where structure.LicensePlateParent == _licensePlateId;
        #
        #    if (structure.RecId != 0)
        #    {
        #        structure.clear();
        #
        #        while select sum(Qty) from asnItem
        #            group by ItemId, uom, LoadId, LoadLineRefRecId, InventDimId
        #            join Module from structure
        #            where asnItem.LicensePlateId        == structure.LicensePlateId  &&
        #                  structure.LicensePlateParent  == _licensePlateId              &&
        #                  structure.Module              == _module
        #        {
        #            if (!hasVendor && structure.Module == WHSModule::Purch)
        #            {
        #                ret += [this.buildControl(#RFLabel,
        #                                          int2str(i),
        #                                          strFmt("@SYS82246", PurchLine::findInventTransId(WHSLoadLine::findbyRecId(asnItem.LoadLineRefRecId).InventTransId).purchTable().vendorName()),
        #                                          1,
        #                                          '',
        #                                          #WHSRFUndefinedDataType,
        #                                          '',
        #                                          0)];
        #                hasVendor = true;
        #            }
        #
        #            if (!hasOrder)
        #            {
        #                ret += [this.buildControl(#RFLabel,
        #                                          int2str(i),
        #                                          strFmt("@WAX3657", WHSLoadLine::findbyRecId(asnItem.LoadLineRefRecId).OrderNum),
        #                                          1,
        #                                          '',
        #                                          #WHSRFUndefinedDataType,
        #                                          '',
        #                                          0)];
        #
        #                hasOrder = true;
        #            }
        #
        #            itemInfo = '';
        #            itemInfo = this.generateItemInfoForReceiving(asnItem);
        #            ret += [this.buildControl(#RFLabel, int2str(i), itemInfo, 1, '', #WHSRFUndefinedDataType, '', 0)];
        #            ++i;
        #        }
        #    }
        #    else
        #    {
        #        while select asnItem
        #            where asnItem.LicensePlateId    == _licensePlateId  &&
        #                  asnItem.Module            == _module
        #        {
        #            if (!hasVendor && asnItem.Module == WHSModule::Purch)
        #            {
        #                ret += [this.buildControl(#RFLabel, int2str(i), strFmt("@SYS82246", PurchLine::findInventTransId(WHSLoadLine::findbyRecId(asnItem.LoadLineRefRecId).InventTransId).purchTable().vendorName()), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #                hasVendor = true;
        #            }
        #
        #            if (!hasOrder)
        #            {
        #                ret += [this.buildControl(#RFLabel,
        #                                          int2str(i),
        #                                          strFmt("@WAX3657", WHSLoadLine::findbyRecId(asnItem.LoadLineRefRecId).OrderNum),
        #                                          1,
        #                                          '',
        #                                          #WHSRFUndefinedDataType,
        #                                          '',
        #                                          0)];
        #
        #                hasOrder = true;
        #            }
        #
        #            itemInfo = '';
        #            itemInfo = this.generateItemInfoForReceiving(asnItem);
        #            ret += [this.buildControl(#RFLabel, int2str(i), itemInfo, 1, '', #WHSRFUndefinedDataType, '', 0)];
        #            ++i;
        #        }
        #    }
        #
        #    if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).ShowDisposition && _module != WHSModule::Transfer)
        #    {
        #        ret = this.buildDispositon(ret, pass.lookupStr(#Disposition), true, true);
        #    }
        #
        #    ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildShortPick
        #container buildShortPick(container  _con,
        #                         str        _extraText = '')
        #{
        #    container           ret = _con;
        #    WMSLocation         location;
        #    WHSLicensePlateId   licensePlateId;
        #    WHSRFDescription1   description1;
        #    WHSRFDescription2   description2;
        #    InventDim           inventDim;
        #    Qty                 qty;
        #    Qty                 inventQty;
        #    UnitOfMeasureSymbol uom;
        #    UnitOfMeasureSymbol inventUOM;
        #    WHSWorkException    shortPickReason;
        #    boolean             first = true;
        #    str                 elements;
        #
        #    description1    = WHSInventTable::find(workLine.ItemId).rfDescription1;
        #    description2    = WHSInventTable::find(workLine.ItemId).rfDescription2;
        #    inventDim       = InventDim::find(workLine.InventDimId);
        #    qty             = workLine.QtyRemain;
        #    inventQty       = workLine.InventQtyRemain;
        #    uom             = workLine.UnitId;
        #    inventUOM       = InventTableModule::find(workLine.ItemId, ModuleInventPurchSales::Invent).UnitId;
        #    licensePlateId  = workTable.TargetLicensePlateId;
        #
        #    if (workLine.wmsLocationId)
        #    {
        #        location = WMSLocation::find(workLine.wmsLocationId, pass.lookup(#InventLocationId));
        #    }
        #
        #    ret += [this.buildControl(#RFLabel, #RFShortPick, "@WAX1322", 1, '',#WHSRFUndefinedDataType, '', 0)];
        #
        #    ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];
        #
        #    if (licensePlateId)
        #    {
        #        ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        #    }
        #
        #    if (location.whsLocationIsLPControlled())
        #    {
        #        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookupStr(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0)];
        #    }
        #    else if (!licensePlateId && !location.whsLocationIsLPControlled())
        #    {
        #        if (!pass.exists(#TargetLicensePlateId) && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP)
        #        {
        #            pass.insert(#TargetLicensePlateId, WHSLicensePlate::generateLicensePlateId(workLine.ItemId, workLine.UnitId));
        #        }
        #
        #        ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, pass.lookupStr(#TargetLicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0)];
        #    }
        #
        #    ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, workLine.ItemId, extendedTypeNum(ItemId), '', 0, false)];
        #
        #    if (workLine.ItemId)
        #    {
        #        if (description1)
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", description1), 1, '',#WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #        else
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(workLine.ItemId).defaultProductName()), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #
        #        if (description2)
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", description2), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #    }
        #
        #    // Build label controls for all dimensions specified above location
        #    ret = this.buildAboveLocationDimensions(ret, inventDim, workLine.ItemId);
        #
        #    ret += [this.buildControl(#RFText, #QtyToPick, "@WAX1327", 1, pass.lookupStr(#QtyToPick), #WHSRFUndefinedDataType, '', 0)];
        #
        #    ret = this.buildUOM(ret, '', false, false, false, pass.lookupStr(#SelectedValueUOM));
        #
        #    while select shortPickReason
        #        where shortPickReason.ExceptionType == WHSExceptionType::ShortPick
        #    {
        #        if (first)
        #        {
        #            elements += shortPickReason.WorkExceptionDesc;
        #            first = false;
        #        }
        #        else
        #        {
        #            elements = elements + '||' + shortPickReason.WorkExceptionDesc;
        #        }
        #    }
        #
        #    ret += [this.buildControl(#RFCombobox, #ShortPickReason, "@SYS86426", 1, elements, #WHSRFUndefinedDataType, '', 0, true, pass.lookupStr(#SelectedValue))];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildShortPickConf
        #container buildShortPickConf(container  _con,
        #                             str        _extraText = '')
        #{
        #    container           ret = _con;
        #    WMSLocation         location;
        #    WHSLicensePlateId   licensePlateId;
        #    WHSRFDescription1   description1;
        #    WHSRFDescription2   description2;
        #    InventDim           inventDim;
        #    Qty                 qty;
        #    Qty                 inventQty;
        #    UnitOfMeasureSymbol uom;
        #    UnitOfMeasureSymbol inventUOM;
        #    boolean             first = true;
        #    str                 elements = '||';
        #
        #    description1    = WHSInventTable::find(workLine.ItemId).rfDescription1;
        #    description2    = WHSInventTable::find(workLine.ItemId).rfDescription2;
        #    inventDim       = InventDim::find(workLine.InventDimId);
        #    qty             = workLine.QtyRemain;
        #    inventQty       = workLine.InventQtyRemain;
        #    uom             = workLine.UnitId;
        #    inventUOM       = InventTableModule::find(workLine.ItemId, ModuleInventPurchSales::Invent).UnitId;
        #    licensePlateId  = workTable.TargetLicensePlateId;
        #
        #    if (workLine.wmsLocationId)
        #    {
        #        location = WMSLocation::find(workLine.wmsLocationId, pass.lookup(#InventLocationId));
        #    }
        #
        #    ret += [this.buildControl(#RFLabel, #RFShortPick, "@WAX1322", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, workLine.wmsLocationId, extendedTypeNum(WMSLocationId), '', 0, false)];
        #
        #    if (licensePlateId)
        #    {
        #        ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        #    }
        #
        #    if (pass.exists(#LicensePlateId))
        #    {
        #        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookup(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        #    }
        #
        #    ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, workLine.ItemId, extendedTypeNum(ItemId), '', 0, false)];
        #
        #    if (workLine.ItemId)
        #    {
        #        if (description1)
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", description1), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #        else
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(workLine.ItemId).defaultProductName()), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #
        #        if (description2)
        #        {
        #            ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", description2), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #        }
        #    }
        #
        #    // Build label controls for all dimensions specified above location
        #    ret = this.buildAboveLocationDimensions(ret, inventDim, workLine.ItemId);
        #
        #    ret += [this.buildControl(#RFText, #QtyToPick, "@WAX1327", 1, pass.lookup(#QtyToPick), #WHSRFUndefinedDataType, '', 0, false)];
        #    ret += [this.buildControl(#RFText, #QtyShort, "@WAX1333", 1, pass.lookup(#QtyShort), #WHSRFUndefinedDataType, '', 0, false)];
        #    ret = this.buildUOM(ret, '', false, false, false, pass.lookupStr(#SelectedValueUOM), false);
        #
        #    ret += [this.buildControl(#RFText, #ReasonString, "@SYS86426", 1, pass.exists(#ShortPickReason) ? WHSWorkException::find(pass.lookup(#ShortPickReason), WHSExceptionType::ShortPick).WorkExceptionDesc : '', #WHSRFUndefinedDataType, '', 0, false)];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildTORecTrackingDimensions
        #protected container buildTORecTrackingDimensions(
        #    container   _con,
        #    ItemId      _itemId,
        #    Qty         _defaultQty)
        #{
        #    container           ret = _con;
        #    InventTransferLine  transferLine;
        #    WHSInventTable      whsInventTable;
        #    ListEnumerator      le;
        #    InventDim           transferLineDim;
        #    str                 qtyString;
        #    InventBatchId       batchId;
        #    boolean             enable;
        #
        #    transferLine = InventTransferLine::find(pass.lookup(#TONum), pass.lookupNum(#TOLineNum));
        #    whsInventTable = WHSInventTable::find(_itemId);
        #    transferLineDim = transferLine.inventDim();
        #    qtyString = WHSWorkExecuteDisplay::num2StrDisplay(_defaultQty);
        #
        #    ret += [this.buildControl(#RFLabel, "@WAX5546", "@WAX5546", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookup(#ItemId), extendedTypeNum(ItemId), '', 0, false)];
        #
        #    if (whsInventTable.rfDescription1)
        #    {
        #        ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", whsInventTable.rfDescription1), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #    }
        #    else
        #    {
        #        ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(whsInventTable.ItemId).defaultProductName()), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #    }
        #
        #    if (whsInventTable.rfDescription2)
        #    {
        #        ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", whsInventTable.rfDescription2), 1, '', #WHSRFUndefinedDataType, '', 0, false)];
        #    }
        #
        #    ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookup(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        #
        #    le = InventDimGroupSetup::newDimensionGroups(0, 0, InventTable::find(_itemId).trackingDimensionGroup()).activeFields().getEnumerator();
        #
        #    while (le.moveNext())
        #    {
        #        switch (le.current())
        #        {
        #            case fieldNum(InventDim, InventBatchId):
        #                enable = transferLineDim.InventBatchId == '';
        #                batchId = pass.lookupStr(#BatchId) ? pass.lookupStr(#BatchId) : this.defaultTORecBatchId(transferLine.TransferId, transferLine.LineNum);
        #                ret += [this.buildControl(#RFText, #BatchId, "@SYS14462", 1, batchId, extendedTypeNum(InventBatchId), '', 0, enable)];
        #                break;
        #
        #            default:
        #                if (transferLineDim.(le.current()))
        #                {
        #                    ret += [this.buildControlForTableField(tableNum(InventDim),
        #                                                           le.current(),
        #                                                           fieldId2name(tableNum(InventDim), le.current()),
        #                                                           1,
        #                                                           transferLineDim.(le.current()),
        #                                                           false)];
        #                }
        #                else
        #                {
        #                    ret += [this.buildControlForTableField(tableNum(InventDim),
        #                                                           le.current(),
        #                                                           fieldId2name(tableNum(InventDim), le.current()),
        #                                                           1,
        #                                                           '',
        #                                                           true)];
        #                }
        #                break;
        #        }
        #    }
        #
        #    ret += [this.buildControl(#RFText, #DimQty, "@SYS105177", 1, qtyString, extendedTypeNum(Qty), '', 0)];
        #    ret = this.buildTrackingDimReceiptUOM(ret, '', false, true, pass.lookupStr(#DimUOM));
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildTrackingDimensionsText
        #protected container buildTrackingDimensionsText(
        #    container       _con,
        #    ItemId          _itemId,
        #    WMSLocationId   _locationId = '',
        #    boolean         _outbound = true,
        #    boolean         _populate = false,
        #    boolean         _enableControls = true,
        #    boolean         _displaySerial = false)
        #{
        #    container       ret = _con;
        #    ListEnumerator  le;
        #
        #    le = InventDimGroupSetup::newDimensionGroups(0, 0, InventTable::find(_itemId).trackingDimensionGroup()).activeFields().getEnumerator();
        #
        #    while (le.moveNext())
        #    {
        #        switch (le.current())
        #        {
        #            case fieldNum(InventDim, InventSerialId):
        #                if (_displaySerial
        #                    || (_outbound && WMSLocation::whsLocationHasSerial(_locationId, _itemId))
        #                    || (!_outbound && WHSInventTable::captureSerial(_itemId) == WHSRFWhenToCapture::Receiving))
        #                {
        #                    ret += [this.buildControl(#RFText,
        #                                              #SerialId,
        #                                              "@WAX1614",
        #                                              1,
        #                                              _populate ? pass.lookupStr(#SerialId) : '',
        #                                              extendedTypeNum(InventSerialId),
        #                                              '',
        #                                              0,
        #                                              _enableControls)];
        #                }
        #                break;
        #
        #            default:
        #                ret += [this.buildControlForTableField(tableNum(InventDim),
        #                                               le.current(),
        #                                               fieldId2name(tableNum(InventDim), le.current()),
        #                                               1,
        #                                               _populate ? pass.lookupStr(fieldId2name(tableNum(InventDim), le.current())) : '',
        #                                               _enableControls)];
        #                break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildTrackingDimReceiptUOM
        #protected container buildTrackingDimReceiptUOM(
        #    container   _con,
        #    str         _label = '',
        #    boolean     _showBlank = false,
        #    boolean     _showOK = true,
        #    str         _selected = '',
        #    boolean     _enabled = true)
        #{
        #    container   ret;
        #    str         elements;
        #    ItemId      itemId;
        #
        #    if (pass.exists(#ItemId))
        #    {
        #        itemId = pass.lookup(#ItemId);
        #    }
        #    elements = this.buildUOMSequenceGroupString(itemId, _showBlank);
        #
        #    ret = this.addTrackingDimRecUOMControl(_con, _label, elements, _selected, _enabled);
        #
        #    if (_showOK)
        #    {
        #        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildUOM
        #container buildUOM(container    _con,
        #                   str          _label = '',
        #                   boolean      _showRemove = false,
        #                   boolean      _showBlank  = false,
        #                   boolean      _showOK     = true,
        #                   str          _selected   = '',
        #                   boolean      _enabled    = true)
        #{
        #    container           ret = _con;
        #    str                 elements;
        #    str                 label = _label ? _label : "@WAX721";      // UOM
        #    ItemId              itemId;
        #
        #    if (pass.exists(#ItemId))
        #    {
        #        itemId = pass.lookup(#ItemId);
        #    }
        #
        #    elements = this.buildUOMSequenceGroupString(itemId, _showBlank);
        #
        #    ret += [this.buildControl(#RFCombobox, #UOM, label, 1, elements, #WHSRFUndefinedDataType, '', 0, _enabled, _selected ? _selected : '')];
        #
        #    if (_showRemove)
        #    {
        #        ret += [this.buildControl(#RFButton, "@SYS26394", "@WAX879", 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #
        #    if (_showOK)
        #    {
        #        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildUOMSequenceGroupString
        #/// <summary>
        #///     Builds a pipe-delimited string containing sequence group unit values.
        #/// </summary>
        #/// <param name="_itemId">
        #///     An item ID to build the string for.
        #/// </param>
        #/// <param name="_showBlank">
        #///     A Boolean value to indicate whether a blank value should be included in the list of available options.
        #/// </param>
        #/// <returns>
        #///     Returns a pipe-delimited string containing sequence group unit values.
        #/// </returns>
        #protected str buildUOMSequenceGroupString(
        #    ItemId  _itemId,
        #    boolean _showBlank)
        #{
        #    WHSInventTable      whsInventTable;
        #    WHSUOMSeqGroupLine  uomSeqGroupLine;
        #    boolean             first = true;
        #    str                 elements;
        #
        #    if (_showBlank)
        #    {
        #        elements = '||';
        #    }
        #
        #    if (_itemId)
        #    {
        #        while select UnitId
        #                from uomSeqGroupLine
        #                order by LineNum
        #            exists join whsInventTable
        #                where whsInventTable.ItemId         == _itemId
        #                   && uomSeqGroupLine.uomSeqGroupId == whsInventTable.uomSeqGroupId
        #        {
        #            if (first)
        #            {
        #                first = false;
        #            }
        #            else
        #            {
        #                elements += '||';
        #            }
        #
        #            elements += uomSeqGroupLine.UnitId;
        #        }
        #    }
        #
        #    return elements;
        #}
      ENDSOURCE
      SOURCE #buildWorkAuditTemplate
        #container buildWorkAuditTemplate(container  _con)
        #{
        #    container                   ret = _con;
        #    WHSWorkAuditTemplateTable   workAuditTemplateTable;
        #    WHSWorkAuditTemplateLine    workAuditTemplateLine;
        #
        #    workAuditTemplateTable  = WHSWorkAuditTemplateTable::find(pass.lookup(#AuditTemplateId));
        #    workAuditTemplateLine   = WHSWorkAuditTemplateLine::find(pass.lookup(#AuditTemplateId), pass.lookup(#AuditSeqNum));
        #
        #    // Header label referencing audit break field
        #    ret += [this.buildControl(#RFLabel, #Scan, strFmt("@WAX736",
        #                                                      workAuditTemplateTable.AuditDisplayLabel,
        #                                                      workTable.(workAuditTemplateTable.AuditBreakFieldNum)), 1, '', #WHSRFUndefinedDataType, '', 0)];
        #
        #    if (workAuditTemplateLine.AuditBreakFunction == WHSAuditBreakFunction::CaptureData)
        #    {
        #        ret += [this.buildControl(#RFText, #Field, workAuditTemplateLine.AuditRFLabel, 1, '', extendedTypeNum(Description), '', 0)];
        #    }
        #    else
        #    {
        #        // If not capture data audit function, display function
        #        ret += [this.buildControl(#RFLabel, #Field, workAuditTemplateLine.AuditRFLabel, 1, '', #WHSRFUndefinedDataType, '', 0)];
        #    }
        #
        #    ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #buildWorkExceptions
        #container buildWorkExceptions(container _con, str _selected = '')
        #{
        #    WHSWorkException    exceptions;
        #    container           ret = _con;
        #    boolean             first = true;
        #    str                 elements = '||';
        #
        #    while select exceptions
        #        where exceptions.ExceptionType == WHSExceptionType::Work
        #    {
        #        if (first)
        #        {
        #            elements = exceptions.WorkExceptionDesc;
        #            first = false;
        #        }
        #        else
        #        {
        #            elements = elements + '||' + exceptions.WorkExceptionDesc;
        #        }
        #    }
        #
        #    ret += [this.buildControl(#RFCombobox, #WHSWorkException, "@WAX639", 1, elements, #WHSRFUndefinedDataType, '', 0, true, _selected)];
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #capturePotency
        #/// <summary>
        #///     Indicates whether potency must be captured during receiving flows.
        #/// </summary>
        #/// <param name="_itemId">
        #///     The item ID.
        #/// </param>
        #/// <returns>
        #///     Returns true if potency must be captured.
        #/// </returns>
        #protected boolean capturePotency(ItemId _itemId = '')
        #{
        #    InventTable inventTable;
        #    ItemId      itemId = _itemId;
        #
        #    if (!itemId)
        #    {
        #        itemId = pass.lookupStr(#ItemId);
        #    }
        #
        #    inventTable = InventTable::findHavingPotencyAttribute(itemId);
        #
        #    return inventTable.RecId != 0;
        #}
      ENDSOURCE
      SOURCE #captureTrackingDimensions
        #/// <summary>
        #/// Determines whether tracking dimensions should be captured during receiving flow.
        #/// </summary>
        #/// <param name="_itemId">
        #/// The item currently being received.
        #/// </param>
        #/// <returns>
        #/// true if tracking dimensions need to be captured; otherwise false.
        #/// </returns>
        #protected boolean captureTrackingDimensions(ItemId _itemId)
        #{
        #    ListEnumerator  le;
        #    boolean         ret;
        #    boolean         captureSerialAtReceiving;
        #
        #    le = InventDimGroupSetup::newDimensionGroups(0, 0, InventTable::find(_itemId).trackingDimensionGroup()).activeFields().getEnumerator();
        #
        #    captureSerialAtReceiving = WHSInventTable::captureSerial(_itemId) == WHSRFWhenToCapture::Receiving;
        #
        #    while (le.moveNext())
        #    {
        #        ret = (le.current() != fieldNum(InventDim, InventSerialId)
        #        ||     captureSerialAtReceiving);
        #
        #        if (ret)
        #        {
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #checkForPickPackWork
        #boolean checkForPickPackWork(WHSWorkId  _sourceWorkId)
        #{
        #    boolean         ret;
        #    WHSWorkTable    newWorkTable;
        #    WHSWorkTable    sourceWorkTable = WHSWorkTable::find(_sourceWorkId);
        #    WHSWorkExecute  workExecute = new WHSWorkExecute();
        #
        #    while select newWorkTable
        #        where newWorkTable.WorkId           != _sourceWorkId                    &&
        #              newWorkTable.InventSiteId     == sourceWorkTable.InventSiteId     &&
        #              newWorkTable.InventLocationId == sourceWorkTable.InventLocationId &&
        #              newWorkTable.OrderNum         == sourceWorkTable.OrderNum         &&
        #              newWorkTable.LoadId           == sourceWorkTable.LoadId           &&
        #              newWorkTable.Frozen           == NoYes::No                        &&
        #              newWorkTable.WorkStatus       <= WHSWorkStatus::Open
        #    {
        #        ret = (workExecute.validatePickPackGrouping(_sourceWorkId, newWorkTable.WorkId) == ''  &&
        #               WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookup(#MenuItem),
        #                                                            workExecute.getFirstOpenLine(newWorkTable.WorkId, pass.lookup(#UserId)).WorkClassId));
        #
        #        if (ret)
        #        {
        #            break;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #checkWarehouseAllowsRFReceipt
        #/// <summary>
        #/// Validates that the warehouse has a default receipt location set that is LP controlled.
        #/// </summary>
        #/// <param name="_inventLocationId">
        #/// The warehouse to check for valid receipt location.
        #/// </param>
        #/// <returns>
        #/// true if the warehouse has a LP controlled default receipt location; otherwise, false
        #/// </returns>
        #protected boolean checkWarehouseAllowsRFReceipt(InventLocationId _inventLocationId)
        #{
        #    InventLocation  inventLocation;
        #    boolean         ret = true;
        #
        #    inventLocation = InventLocation::find(_inventLocationId);
        #
        #    if (!inventLocation.wmsLocationIdDefaultReceipt || !WMSLocation::find(inventLocation.wmsLocationIdDefaultReceipt, _inventLocationId).whsLocationIsLPControlled())
        #    {
        #        ret = false;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #classDeclaration
        #public abstract class WhsWorkExecuteDisplay
        #{
        #    #WHSWorkExecuteControlElements
        #    #WHSWorkExecuteDisplayCases
        #    #WHSRF
        #
        #    // Container structure constants
        #    #define.StateInfo(1)
        #    #define.PassthroughInfo(2)
        #    #define.ControlsStart(3)
        #
        #    // StateInfo sub-container constants.
        #    #define.StateInfoMode(1)
        #    #define.StateInfoStep(2)
        #
        #    WHSWorkExecuteMode  mode;
        #    int                 step;
        #
        #    WHSWorkLine         workLine;
        #    WHSUserId           userId;
        #    WHSRFPassthrough    pass;
        #    WHSWorkTable        workTable;
        #}
      ENDSOURCE
      SOURCE #clearClickedButtons
        #container clearClickedButtons(container     _con)
        #{
        #    container       ret = _con;
        #    int             i;
        #    int             length;
        #
        #    length = conLen(ret);
        #
        #    if (length > 2)
        #    {
        #        for (i = 3; i <= length; ++i)
        #        {
        #            if (conPeek(conPeek(ret, i), #controlType) == #RFButton)
        #            {
        #                ret = conPoke(ret, i, conPoke(conPeek(ret, i), #data, ''));
        #            }
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #clearErrors
        #container clearErrors(container     _con)
        #{
        #    container       ret = _con;
        #    int             i;
        #    int             length;
        #
        #    length = conLen(ret);
        #
        #    for (i = 3; i <= length; ++i)
        #    {
        #        ret = conPoke(ret, i, conPoke(conPeek(ret, i), #error, ''));
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #clearPassBelowLicensePlate
        #/// <summary>
        #/// Clears out inventory dimension values in the passthrough that are below license plate in the reservation hierarchy.
        #/// </summary>
        #/// <param name="_itemId">
        #/// The Id of the item which determines the reservation hierarchy, thus, determining dimensions below license plate.
        #/// </param>
        #protected void clearPassBelowLicensePlate(ItemId _itemId)
        #{
        #    WHSReservationHierarchyProvider     reservationHierarchyProvider;
        #    WHSReservationHierarchyElementData  elementData;
        #    Enumerator                          enumerator;
        #
        #    reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();
        #
        #    enumerator = reservationHierarchyProvider.getDimListBelowLicensePlate(
        #                        InventTable::find(_itemId),
        #                        WHSReservationHierarchySortOrder::TopDown)
        #                    .getEnumerator();
        #
        #    while (enumerator.moveNext())
        #    {
        #        elementData = enumerator.current();
        #        pass.remove(fieldId2name(tableNum(InventDim), elementData.parmDimensionFieldId()));
        #    }
        #}
      ENDSOURCE
      SOURCE #clearPassBelowLocation
        #/// <summary>
        #/// Clears out inventory dimension values in the passthrough that are below location in the reservation hierarchy.
        #/// </summary>
        #/// <param name="_itemId">
        #/// The Id of the item which determines the reservation hierarchy, thus, determining dimensions below license plate.
        #/// </param>
        #protected void clearPassBelowLocation(ItemId _itemId)
        #{
        #    WHSReservationHierarchyProvider     reservationHierarchyProvider;
        #    WHSReservationHierarchyElementData  elementData;
        #    Enumerator                          enumerator;
        #
        #    reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();
        #
        #    enumerator = reservationHierarchyProvider.getDimListBelowLocation(
        #                        InventTable::find(_itemId),
        #                        WHSReservationHierarchySortOrder::TopDown)
        #                    .getEnumerator();
        #
        #    while (enumerator.moveNext())
        #    {
        #        elementData = enumerator.current();
        #        pass.remove(fieldId2name(tableNum(InventDim), elementData.parmDimensionFieldId()));
        #    }
        #}
      ENDSOURCE
      SOURCE #combineMaps
        #WHSRFPassthrough combineMaps(WHSRFPassthrough _targetMap, WHSRFPassthrough _sourceMap)
        #{
        #    MapEnumerator       me;
        #    str                 key;
        #    str                 value;
        #    WHSRFPassthrough    ret = _targetMap;
        #
        #    me = _sourceMap.getEnumerator();
        #
        #    while (me.moveNext())
        #    {
        #        key = me.currentKey();
        #        value = me.currentValue();
        #
        #        ret.insert(key, value);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #countUniqueLPInLocation
        #int countUniqueLPInLocation(InventLocationId    _inventLocationId,
        #                            InventSiteId        _inventSiteId,
        #                            WMSLocationId       _locationId)
        #{
        #    InventDim       inventDim;
        #    InventSum       inventSum;
        #
        #    select count(RecId) from inventDim
        #        join InventDimId, PhysicalInvent from inventSum
        #        where inventDim.InventDimId         == inventSum.InventDimId    &&
        #              inventDim.InventLocationId    == _inventLocationId        &&
        #              inventDim.InventSiteId        == _inventSiteId            &&
        #              inventDim.wmsLocationId       == _locationId              &&
        #              inventDim.LicensePlateId      != ''                       &&
        #              inventSum.PhysicalInvent       > 0;
        #
        #    return int642int(inventDim.RecId);
        #}
      ENDSOURCE
      SOURCE #createAssignSerialDimTracking
        #void createAssignSerialDimTracking()
        #{
        #    WHSDimTracking      dimTracking;
        #    InventDim           inventDim;
        #    WHSWorkInventTrans  workInventTrans;
        #    List                listDimbelowLicensePlate;
        #
        #    ttsbegin;
        #
        #    select firstonly InventTransIdParent, ItemId from workInventTrans
        #        where workInventTrans.WorkId    == workLine.WorkId
        #        &&    workInventTrans.LineNum   == workLine.LineNum;
        #
        #    inventDim = workLine.inventDimWithLocation();
        #
        #    if (pass.exists(#LicensePlateId))
        #    {
        #        inventDim.LicensePlateId    = pass.lookup(#LicensePlateId);
        #    }
        #
        #    listDimbelowLicensePlate = WHSReservationHierarchyProvider::construct().getDimListBelowLicensePlate(
        #                                                                                InventTable::find(workInventTrans.ItemId),
        #                                                                                WHSReservationHierarchySortOrder::TopDown);
        #
        #    this.initInventDimFromPassDimList(inventDim, WHSReservationHierarchyInventDimUtil::hierarchyList2FieldIdList(listDimbelowLicensePlate));
        #
        #    inventDim = InventDim::findOrCreate(inventDim);
        #
        #    dimTracking.WorkId              = workLine.WorkId;
        #    dimTracking.LineNum             = workLine.LineNum;
        #    dimTracking.InventDimId         = inventDim.InventDimId;
        #    dimTracking.InventTransIdParent = workInventTrans.InventTransIdParent;
        #    dimTracking.Qty                 = 1;
        #    dimTracking.insert();
        #
        #    // Remove serial from pass through once dimTracking has been created.
        #    // We don't want to use this serial any further when evaluating dimensions, such as in future loops in method processWorkLine.
        #    pass.remove(#SerialId);
        #
        #    ttscommit;
        #}
      ENDSOURCE
      SOURCE #createInventDimFromPass
        #/// <summary>
        #/// Creates an inventDim from the current pass through values.
        #/// </summary>
        #/// <returns>
        #/// An inventDim record.
        #/// </returns>
        #/// <remarks>
        #/// This method relies on the keys of the pass through map to match inventDim field names.
        #/// </remarks>
        #protected InventDim createInventDimFromPass()
        #{
        #    InventDim inventDim;
        #
        #    this.initInventDimFromPassDimList(inventDim, InventDim::dimFieldsList());
        #
        #    return InventDim::findOrCreate(inventDim);
        #}
      ENDSOURCE
      SOURCE #defaultTORecBatchId
        #protected InventBatchId defaultTORecBatchId(
        #    InventTransferId    _transferId,
        #    LineNum             _lineNum)
        #{
        #    InventTransferLine  transferLine;
        #    InventTrans         inventTrans;
        #    InventTransOrigin   inventTransOrigin;
        #    InventBatchId       batchId;
        #
        #    // First try to default off transfer line
        #    batchId = transferLine.inventDim().InventBatchId;
        #
        #    // Next try to default based on transactions
        #    if (!batchId)
        #    {
        #        batchId = InventTrans::findTransId(InventTransferLine::find(pass.lookup(#TONum), pass.lookupNum(#TOLineNum)).InventTransIdReceive).inventDim().InventBatchId;
        #
        #        while select inventTrans
        #            where inventTrans.ItemId        == pass.lookup(#ItemId)
        #            &&    inventTrans.StatusReceipt == StatusReceipt::Ordered
        #            join InventTransId from inventTransOrigin
        #                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
        #                exists join transferLine
        #                    where transferLine.InventTransIdReceive == inventTransOrigin.InventTransId
        #                    &&    transferLine.TransferId           == _transferId
        #                    &&    transferLine.LineNum              == _lineNum
        #        {
        #            if (inventTrans.inventDim().InventBatchId != batchId)
        #            {
        #                batchId = '';
        #                break;
        #            }
        #        }
        #    }
        #
        #    // Next try to default based off previous receipts
        #    if (pass.lookupStr(#SessionBatchId))
        #    {
        #        batchId = pass.lookup(#SessionBatchId);
        #    }
        #
        #    return batchId;
        #}
      ENDSOURCE
      SOURCE #determineRestart
        #container determineRestart(container _con)
        #{
        #    container   data = _con;
        #
        #    if (workLine && !workLine.WorkStop)
        #    {
        #        pass = this.resetPassthrough(data);
        #        pass.insert(#WorkId, workLine.WorkId);
        #        pass.insert(#LineNum, workLine.LineNum);
        #        pass.insert(#DimTrackingDelay, 1);
        #        this.clearPassBelowLicensePlate(workLine.ItemId);
        #        data = conPoke(data, 2, pass.pack());
        #        step = #StepOne;
        #
        #        if (pass.exists(#GroupPutawayConfirm))
        #        {
        #            pass.remove(#GroupPutawayConfirm);
        #        }
        #    }
        #    else
        #    {
        #        if (workLine.WorkId && WHSWorkTemplateLine::findByRecId(workLine.WorkTemplateLineRecId).Freeze)
        #        {
        #            WHSWorkTable::freezeOrUnfreezeWork(workLine.WorkId, true);
        #        }
        #        WHSWorkTable::lockUnlockWork(workLine.WorkId, '');
        #        pass = this.resetPassthrough(data, false);
        #        pass.insert(#WorkComplete, 1);
        #        data = conPoke(data, 2, pass.pack());
        #        step = #Restart;
        #    }
        #
        #    return data;
        #}
      ENDSOURCE
      SOURCE #displayBatchDisposition
        #/// <summary>
        #///     Determines whether batch disposition must be displayed on the RF screen.
        #/// </summary>
        #/// <returns>
        #///     Returns true if batch disposition must be displayed.
        #/// </returns>
        #protected boolean displayBatchDisposition()
        #{
        #    boolean             ret;
        #    InventTable         inventTable;
        #    WHSRFMenuItemTable  menuItemTable;
        #
        #    inventTable = InventTable::find(pass.lookupStr(#ItemId));
        #    menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));
        #
        #    if (inventTable.whsBatchActive()
        #    &&  (menuItemTable.ShowBatchDisposition
        #    ||   menuItemTable.WorkActivity == WHSWorkActivity::ChangeBatchDisposition))
        #    {
        #        ret = true;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #displayForm
        #abstract container displayForm(container _con, str _buttonClicked = '')
        #{
        #}
      ENDSOURCE
      SOURCE #fieldValueChanged
        #/// <summary>
        #///     Determines whether a given field value has changed.
        #/// </summary>
        #/// <param name="_fieldValues">
        #///     The container of field values.
        #/// </param>
        #/// <param name="_controlName">
        #///     The name of the RF control to check.
        #/// </param>
        #/// <returns>
        #///     Returns true if the field value has changed.
        #/// </returns>
        #protected boolean fieldValueChanged(WHSRFPassthrough _fieldValues, str _controlName)
        #{
        #    boolean             ret;
        #    WHSRFPassthrough    fieldValues = _fieldValues;
        #
        #    if (pass.exists(_controlName) && fieldValues.exists(_controlName))
        #    {
        #        ret = fieldValues.lookup(_controlName) != pass.lookup(_controlName);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #fillPassFromInventDim
        #/// <summary>
        #/// Creates entries in the pass through map for each field in the inventDim.
        #/// </summary>
        #/// <param name="_inventDim">
        #/// The inventDim record that will be used to fill the pass through.
        #/// </param>
        #/// <remarks>
        #/// This method relies on the keys of the pass through map to match inventDim field names.
        #/// </remarks>
        #protected void fillPassFromInventDim(InventDim _inventDim)
        #{
        #    List            dimList;
        #    ListEnumerator  enumerator;
        #    FieldName       fieldName;
        #
        #    // Fields might not have been selected on the specified buffers, or might have been updated since selection
        #    _inventDim.checkInvalidFieldAccess(false);
        #
        #    dimList = InventDim::dimFieldsList();
        #    enumerator = dimList ? dimList.getEnumerator() : null;
        #
        #    while (enumerator.moveNext())
        #    {
        #        if (_inventDim.(enumerator.current()))
        #        {
        #            fieldName = fieldId2name(_inventDim.TableId, enumerator.current());
        #            pass.insert(fieldName, _inventDim.(enumerator.current()));
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #findDefaultBatch
        #InventBatchId findDefaultBatch(InventTable _inventTable, WMSLocation   _location)
        #{
        #    InventBatchId       tmpBatchId;
        #    InventSum           inventSum;
        #    InventDim           inventDim;
        #
        #    while select InventDimId, ItemId, PhysicalInvent from inventSum
        #        join InventBatchId from inventDim
        #        where inventSum.InventDimId         == inventDim.InventDimId        &&
        #              inventSum.ItemId              == _inventTable.ItemId          &&
        #              inventSum.PhysicalInvent      >  0                            &&
        #              inventDim.InventLocationId    == _location.InventLocationId   &&
        #              inventDim.wmsLocationId       == _location.wmsLocationId      &&
        #              inventDim.InventBatchId       != ''
        #    {
        #        if (tmpBatchId && tmpBatchId != inventDim.InventBatchId)
        #        {
        #            tmpBatchId = '';
        #            break;
        #        }
        #        tmpBatchId = inventDim.InventBatchId;
        #    }
        #
        #    return tmpBatchId;
        #}
      ENDSOURCE
      SOURCE #generateItemDimension
        #str generateItemDimension(ItemId _itemId, InventDimId _inventDimId)
        #{
        #    InventDimParm   inventDimParm = InventTable::find(_itemId).inventDimParmProductDimensions();
        #    InventDim       inventDim = InventDim::find(_inventDimId);
        #    List            dimList;
        #    ListEnumerator  le;
        #    FieldId         dimFieldId;
        #    str             ret;
        #
        #    dimList     = InventDim::dimFieldsList();
        #    le          = dimList.getEnumerator();
        #
        #    while (le.moveNext())
        #    {
        #        dimFieldId = le.current();
        #
        #        if (inventDim.(dimFieldId)
        #        &&  dimFieldId  != fieldNum(InventDim, InventSiteId)
        #        &&  dimFieldId  != fieldNum(InventDim, InventLocationId)
        #        &&  dimFieldId  != fieldNum(InventDim, wmsLocationId)
        #        &&  dimFieldId  != fieldNum(InventDim, LicensePlateId))
        #        {
        #            ret += '\n' + strFmt(new DictField(tableNum(InventDim), dimFieldId).label() + ': ' + inventDim.(dimFieldId));
        #        }
        #    }
        #
        #    return ret;
        #}
        #
      ENDSOURCE
      SOURCE #generateItemInfoForLicensePlate
        #str generateItemInfoForLicensePlate(InventSum _inventSum, WMSLocationId _locationId)
        #{
        #    WHSInventTable      whsInventTable = WHSInventTable::find(_inventSum.ItemId);
        #    InventTable         inventTable    = InventTable::find(_inventSum.ItemId);
        #    UnitOfMeasureSymbol unitID;
        #    str                 ret;
        #    str                 desc1 = '\n        ' + inventTable.defaultProductName();
        #    str                 desc2;
        #    str                 dimensions;
        #
        #    if (whsInventTable.rfDescription1)
        #    {
        #        desc1 = '\n        ' + whsInventTable.rfDescription1;
        #    }
        #    if (whsInventTable.rfDescription2)
        #    {
        #        desc2 = '\n        ' + whsInventTable.rfDescription2 + '\n';
        #    }
        #    else
        #    {
        #        desc1 = desc1 + '\n';
        #    }
        #
        #    unitID = InventTableModule::find(inventTable.ItemId, ModuleInventPurchSales::Invent).UnitId;
        #    dimensions = this.generateItemDimension(inventTable.ItemId, _inventSum.InventDimId);
        #
        #    ret = strFmt("@WAX737" + '\n' + "@WAX744",     // Location: %1\nItem Id: %2%3%4Qty: %5 %6%7
        #                 _locationId,
        #                 inventTable.ItemId,
        #                 desc1,
        #                 desc2,
        #                 _inventSum.PhysicalInvent,
        #                 unitID,
        #                 dimensions);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #generateItemInfoForLocation
        #str generateItemInfoForLocation(InventSum _inventSum, WMSLocationId _locationId, WHSLicensePlateId _licensePlateId)
        #{
        #    WHSInventTable      whsInventTable = WHSInventTable::find(_inventSum.ItemId);
        #    InventTable         inventTable = InventTable::find(_inventSum.ItemId);
        #    UnitOfMeasureSymbol unitID;
        #    Qty                 availQty;
        #    str                 ret;
        #    str                 desc1 = '\n        ' + inventTable.defaultProductName();
        #    str                 desc2;
        #    str                 dimensions;
        #
        #    if (whsInventTable.rfDescription1)
        #    {
        #        desc1 = '\n        ' + whsInventTable.rfDescription1;
        #    }
        #    if (whsInventTable.rfDescription2)
        #    {
        #        desc2 = '\n        ' + whsInventTable.rfDescription2 + '\n';
        #    }
        #    else
        #    {
        #        desc1 = desc1 + '\n';
        #    }
        #
        #    unitID = InventTableModule::find(inventTable.ItemId, ModuleInventPurchSales::Invent).UnitId;
        #    dimensions = this.generateItemDimension(inventTable.ItemId, _inventSum.InventDimId);
        #
        #    if (_licensePlateId)
        #    {
        #        ret = strFmt("@WAX740" + '\n' + "@WAX744",     // License Plate: %1\nItem Id: %2%3%4Qty: %5 %6%7
        #                     _licensePlateId,
        #                     inventTable.ItemId,
        #                     desc1,
        #                     desc2,
        #                     _inventSum.PhysicalInvent,
        #                     unitID,
        #                     dimensions);
        #    }
        #    else
        #    {
        #        ret = strFmt("@WAX741",     // Item Id: %1%2%3Qty: %4 %5%6
        #                     inventTable.ItemId,
        #                     desc1,
        #                     desc2,
        #                     _inventSum.PhysicalInvent + _inventSum.Picked,
        #                     UnitOfMeasureTranslation::findByTranslation(UnitOfMeasure::unitOfMeasureIdBySymbol(unitID), Global::currentUserLanguage()).Description,
        #                     dimensions);
        #
        #        if (_inventSum.Picked)
        #        {
        #            ret += strFmt('\n' + "@WAX2725",
        #                          _inventSum.Picked,
        #                          UnitOfMeasureTranslation::findByTranslation(UnitOfMeasure::unitOfMeasureIdBySymbol(unitID), Global::currentUserLanguage()).Description);
        #        }
        #
        #        availQty = WHSInventOnHand::getWorkPhysicalAvail(_inventSum.ItemId, _inventSum.InventDimId);
        #
        #        if (availQty < _inventSum.PhysicalInvent)
        #        {
        #            ret += strFmt('\n' + "@WAX2726",
        #                          _inventSum.PhysicalInvent - availQty,
        #                          UnitOfMeasureTranslation::findByTranslation(UnitOfMeasure::unitOfMeasureIdBySymbol(unitID), Global::currentUserLanguage()).Description);
        #
        #            ret += strFmt('\n' + "@WAX2727",
        #                          availQty,
        #                          UnitOfMeasureTranslation::findByTranslation(UnitOfMeasure::unitOfMeasureIdBySymbol(unitID), Global::currentUserLanguage()).Description);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #generateItemInfoForProdId
        #str generateItemInfoForProdId(ProdId _prodId)
        #{
        #    ProdTable           prodTable = ProdTable::find(_prodId);
        #    WHSInventTable      whsInventTable = WHSInventTable::find(prodTable.ItemId);
        #    str                 ret;
        #    str                 desc1;
        #    str                 desc2;
        #    str                 dimensions;
        #
        #    if (whsInventTable.rfDescription1)
        #    {
        #        desc1 = '\n        ' + whsInventTable.rfDescription1;
        #    }
        #    if (whsInventTable.rfDescription2)
        #    {
        #        desc2 = '\n        ' + whsInventTable.rfDescription2 + '\n';
        #    }
        #    else
        #    {
        #        desc1 = desc1 + '\n';
        #    }
        #
        #    dimensions = this.generateItemDimension(prodTable.ItemId, prodTable.InventDimId);
        #
        #    ret = strFmt("@WAX739",     // Item Id: %1%2%3%4
        #                 prodTable.ItemId,
        #                 desc1,
        #                 desc2,
        #                 dimensions);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #generateItemInfoForReceiving
        #str generateItemInfoForReceiving(WHSASNItem _asnItem)
        #{
        #    WHSInventTable      whsInventTable = WHSInventTable::find(_asnItem.ItemId);
        #    InventTable         inventTable = InventTable::find(_asnItem.ItemId);
        #    UnitOfMeasureSymbol unitID;
        #    str                 ret;
        #    str                 desc1;
        #    str                 desc2;
        #    str                 dimensions;
        #    str                 convertedQty;
        #
        #    if (whsInventTable.rfDescription1)
        #    {
        #        desc1 = '\n        ' + whsInventTable.rfDescription1;
        #    }
        #    if (whsInventTable.rfDescription2)
        #    {
        #        desc2 = '\n        ' + whsInventTable.rfDescription2 + '\n';
        #    }
        #    else
        #    {
        #        desc1 = desc1 + '\n';
        #    }
        #
        #    unitID = InventTableModule::find(inventTable.ItemId, ModuleInventPurchSales::Invent).UnitId;
        #    dimensions = this.generateItemDimension(_asnItem.ItemId, _asnItem.InventDimId);
        #
        #    if (unitID != _asnItem.uom)
        #    {
        #        convertedQty = strFmt('\n        %1 %2',
        #                              UnitOfMeasureConverter::convert(_asnItem.Qty,
        #                                                              UnitOfMeasure::unitOfMeasureIdBySymbol(_asnItem.uom),
        #                                                              UnitOfMeasure::unitOfMeasureIdBySymbol(unitID),
        #                                                              NoYes::No,
        #                                                              InventTable::itemProduct(_asnItem.ItemId),
        #                                                              NoYes::No),
        #                              unitID);
        #    }
        #
        #    ret = strFmt("@WAX734",     // Item Id: %1%2%3Qty: %4 %5%6%7
        #                 _asnItem.ItemId,
        #                 desc1,
        #                 desc2,
        #                 _asnItem.Qty,
        #                 _asnItem.uom,
        #                 convertedQty,
        #                 dimensions);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getButtonClicked
        #str getButtonClicked(container _con)
        #{
        #    int     length;
        #    int     i = 3;
        #    str     ret;
        #
        #    length = conLen(_con);
        #
        #    while (i <= length)
        #    {
        #        if (conPeek(conPeek(_con, i), 1) == #RFButton &&
        #            conPeek(conPeek(_con, i), #data) == '1')
        #        {
        #            ret = conPeek(conPeek(_con, i), #name);
        #            break;
        #        }
        #        ++i;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getControlLocation
        #/// <summary>
        #///     Get the location of the specified RF control.
        #/// </summary>
        #/// <param name="_con">
        #///     The RF container variable.
        #/// </param>
        #/// <param name="_controlName">
        #///     The name of the RF control.
        #/// </param>
        #/// <returns>
        #///     Returns the location of the specified RF control.
        #/// </returns>
        #protected int getControlLocation(container _con, str _controlName)
        #{
        #    container   ret = _con;
        #    int         conLength;
        #    int         i;
        #    container   controlCon;
        #    int         controlLoc;
        #    str         controlName;
        #
        #    conLength = conLen(ret);
        #
        #    for (i = #FieldControlStartLoc; i <= conLength; i++)
        #    {
        #        controlCon  = conPeek(ret, i);
        #        controlName = conPeek(controlCon, #name);
        #
        #        if (controlName == _controlName)
        #        {
        #            controlLoc = i;
        #            break;
        #        }
        #    }
        #
        #    return controlLoc;
        #}
      ENDSOURCE
      SOURCE #getDefaultBatchDispositionCode
        #/// <summary>
        #///     Gets the default batch disposition code.
        #/// </summary>
        #/// <param name="_itemId">
        #///     The item identifier.
        #/// </param>
        #/// <returns>
        #///     Returns a container identifying the default batch disposition code, as well as whether a blank value should be included in the element dropdown.
        #/// </returns>
        #protected container getDefaultBatchDispositionCode(ItemId _itemId)
        #{
        #    PdsBatchDispositionCode defaultValue;
        #    InventBatchId           inventBatchId;
        #    boolean                 showBlank;
        #    WHSReceiptId            receiptId;
        #
        #    // Determine the inventory batch ID
        #    inventBatchId = this.getInventBatchId();
        #
        #    receiptId = pass.lookupStr(#ReceiptId);
        #
        #    if (WHSInventBatchReceiptDetails::exist(receiptId, _itemId, inventBatchId))
        #    {
        #        defaultValue = WHSInventBatchReceiptDetails::find(receiptId, _itemId, inventBatchId).PdsBatchDispositionCode;
        #    }
        #    else if (InventBatch::exist(_itemId, inventBatchId))
        #    {
        #        defaultValue = InventBatch::find(inventBatchId, _itemId).PdsDispositionCode;
        #    }
        #    else
        #    {
        #        defaultValue = InventModelGroup::find(InventModelGroupItem::findByItemIdLegalEntity(_itemId).ModelGroupId).PdsDispositionCode;
        #    }
        #
        #    // Include a blank value if a batch disposition code could not be defaulted.
        #    if (!defaultValue)
        #    {
        #        showBlank = true;
        #    }
        #
        #    pass.insert(#BatchDispositionDefault, defaultValue);
        #
        #    return [defaultValue, showBlank];
        #}
      ENDSOURCE
      SOURCE #getDefaultDimValue
        #/// <summary>
        #/// Determines if for specified dim criteria there is more than one value for a inventory dimension field in physical inventory.
        #/// </summary>
        #/// <param name="_inventDimCriteria">
        #/// The inventory dimension criteria.
        #/// </param>
        #/// <param name="_dimFieldId">
        #/// The inventory dimension field being evalued for mutilpe values in inventory.
        #/// </param>
        #/// /// <param name="_itemId">
        #/// The Id of the item which we are trying determine if inventory allows defaulting of the next dimension.
        #/// </param>
        #/// <returns>
        #/// A container with the values: <c>InventDim</c> record with the _dimFieldId filled if there is only a single value based on the query;
        #/// otherwise, it returns a blank inventDim. A boolean value to determine if a prompt is needed.
        #/// </returns>
        #protected container getDefaultDimValue(
        #    InventDim   _inventDimCriteria,
        #    FieldId     _dimFieldId,
        #    ItemId      _itemId)
        #{
        #    InventDim               inventDim;
        #    InventDim               returnDim;
        #    Query                   query;
        #    QueryBuildDataSource    qbds;
        #    QueryRun                queryRun;
        #    Counter                 i;
        #
        #    query = new Query();
        #    qbds = query.addDataSource(tableNum(InventDim));
        #    qbds.addGroupByField(_dimFieldId);
        #    InventDim::queryAddRangeCriteria(qbds, _inventDimCriteria);
        #    qbds.addRange(_dimFieldId).value(SysQuery::valueNotEmptyString());
        #    qbds = qbds.addDataSource(tableNum(InventSum));
        #    qbds.addRange(fieldNum(InventSum, ItemId)).value(_itemId);
        #    qbds.relations(true);
        #    qbds.addRange(fieldNum(InventSum, PhysicalInvent)).value(SysQuery::value('>0'));
        #
        #    queryRun = new QueryRun(query);
        #
        #    while (queryRun.next())
        #    {
        #        ++i;
        #        if (i == 2)
        #        {
        #            returnDim.clear();
        #            inventDim.clear();
        #            break;
        #        }
        #        inventDim = queryRun.get(tableNum(InventDim));
        #        returnDim.(_dimFieldId) = inventDim.(_dimFieldId);
        #    }
        #
        #    return [returnDim, i > 1];
        #}
      ENDSOURCE
      SOURCE #getDefaultLPInventStatusId
        #WHSInventStatusId getDefaultLPInventStatusId(WHSLicensePlateId  _licensePlateId)
        #{
        #    InventDim       inventDim;
        #    InventSum       inventSum;
        #
        #    if (_licensePlateId)
        #    {
        #        select firstonly InventStatusId from inventDim
        #            where inventDim.LicensePlateId  == _licensePlateId
        #            &&    inventDim.InventStatusId  != ''
        #            exists join inventSum
        #                where inventDim.InventDimId     == inventSum.InventDimId
        #                &&    inventSum.Closed          == NoYes::No
        #                &&    inventSum.PhysicalInvent   > 0;
        #    }
        #
        #    return inventDim.InventStatusId;
        #}
      ENDSOURCE
      SOURCE #getInventBatchId
        #/// <summary>
        #///     Determines the scanned inventory batch ID.
        #/// </summary>
        #/// <returns>
        #///     Returns the scanned inventory batch ID.
        #/// </returns>
        #protected InventBatchId getInventBatchId()
        #{
        #    InventBatchId   inventBatchId;
        #    InventDim       purchLineInventDim;
        #
        #    purchLineInventDim = PurchLine::find(pass.lookupStr(#PONum), pass.lookupInt64(#POLineNum)).inventDim();
        #
        #    if (purchLineInventDim.InventBatchId)
        #    {
        #        inventBatchId = purchLineInventDim.InventBatchId;
        #    }
        #    else if (pass.hasValue(#SessionBatchId))
        #    {
        #        inventBatchId = pass.lookup(#SessionBatchId);
        #    }
        #    else
        #    {
        #        inventBatchId = pass.lookupStr(#BatchId);
        #    }
        #
        #    return inventBatchId;
        #}
      ENDSOURCE
      SOURCE #getPickHeaderLabel
        #/// <summary>
        #/// Gets a header label for picking operation.
        #/// </summary>
        #/// <param name="_movementStr">
        #/// A specified <c>string</c> which should be used as a header.
        #/// </param>
        #/// <returns>
        #/// A header label for picking operation.
        #/// </returns>
        #public str getPickHeaderLabel(str _movementStr)
        #{
        #    return strFmt("@WAX1275", _movementStr);
        #}
      ENDSOURCE
      SOURCE #getSerialItemQty
        #InventQty getSerialItemQty(WHSLicensePlateId     _licensePlateId = '')
        #{
        #    InventDim   inventDim;
        #    InventSum   inventSum;
        #
        #    select sum(PhysicalInvent) from inventSum
        #        join InventDimId, InventLocationId, wmsLocationId, LicensePlateId from inventDim
        #        where inventSum.InventDimId         == inventDim.InventDimId        &&
        #              inventDim.InventLocationId    == workTable.InventLocationId   &&
        #              inventDim.wmsLocationId       == workLine.wmsLocationId       &&
        #              inventDim.LicensePlateId      == _licensePlateId              &&
        #              inventSum.ItemId              == workLine.ItemId              &&
        #              inventSum.PhysicalInvent       > 0;
        #
        #    return min(workLine.InventQtyRemain, inventSum.PhysicalInvent);
        #}
      ENDSOURCE
      SOURCE #getStep
        #container getStep(container _con, WHSWorkExecuteMode _mode)
        #{
        #    WHSLicensePlateLabelBuild       labelBuild;
        #    WHSWorkExecute                  workExecute = new WHSWorkExecute();
        #    WMSLocation                     location;
        #    container                       con = _con;
        #    container                       ret;
        #    boolean                         recall;
        #    str                             message = '';
        #
        #    location = WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId);
        #    pass.insert(#WorkId, workLine.WorkId);
        #    pass.insert(#LineNum, workLine.LineNum);
        #    pass.insert(#WMSLocationId, location.wmsLocationId);
        #    pass.insert(#InventDimId, workLine.InventDimId);
        #    pass.insert(#ItemId, workLine.ItemId);
        #    pass.insert(#UOM, workLine.UnitId);
        #    pass.insert(#QtyLeft, workLine.InventQtyRemain);
        #    pass.insert(#QtyWork, workLine.QtyWork);
        #    pass.insert(#InventQtyWork, workLine.InventQtyWork);
        #    pass.insert(#IsLicensePlateControlled, location.whsLocationIsLPControlled());
        #    pass.insert(#IsMultiSKU, WHSWorkTable::find(workLine.WorkId).WorkIsMultiSKU);
        #    pass.insert(#WHSWorkTypeCustomCode, workLine.WorkTypeCustomCode);
        #
        #    if (pass.exists(#WorkComplete) && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).MenuItemDirectedBy == WHSMenuItemDirectedBy::SystemDirected)
        #    {
        #        ret = conNull();
        #        ret = this.addErrorLabel(ret, "@WAX866", WHSRFColorText::Success);
        #        pass.remove(#WorkComplete);
        #    }
        #
        #    if (pass.exists(#CheckDigit))
        #    {
        #        pass.remove(#CheckDigit);
        #    }
        #    else if (pass.exists(#LocVerification))
        #    {
        #        pass.remove(#LocVerification);
        #    }
        #
        #    if (!location.wmsLocationId && (workLine.WorkType != WHSWorkType::Custom
        #                                && workLine.WorkType != WHSWorkType::Print))
        #    {
        #        ret = this.buildGetLocation(ret);
        #        step = #NoLocation;
        #    }
        #    else
        #    {
        #        switch (workLine.WorkType)
        #        {
        #            case WHSWorkType::Pick:
        #                if ((this.hasComments()                                                     ||
        #                     WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).rfDisplayPickSummary) &&
        #                    !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)            &&
        #                    !pass.exists(#CommentsDisplayed))
        #                {
        #                    ret = this.buildComments(ret);
        #                    step = #RFPickingComment;
        #                }
        #                else
        #                {
        #                    ret = this.buildPick(ret, '');
        #                    step = #Pick;
        #                }
        #                break;
        #
        #            case WHSWorkType::Put:
        #                if (!pass.exists(#GroupPutawayFail)
        #                &&  ((WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GroupPutaway
        #                &&  WHSWorkGrouping::validateGroupPutaway(pass.lookup(#WorkGroupingId), pass.lookup(#UserId)))
        #                ||  (!WHSWorkLine::getNextOppositeWorkLine(workLine.WorkId, workLine.LineNum, workLine.WorkType)
        #                &&  WHSWorkTable::multipleFinalPutsAllEqual(workLine.WorkId))))
        #                {
        #                    ret = this.buildGroupedPutaway(ret);
        #                    step = #Put;
        #
        #                    if (!pass.exists(#GroupPutaway))
        #                    {
        #                        pass.insert(#GroupPutaway, 1);
        #                    }
        #                    else
        #                    {
        #                        pass.insert(#GroupPutawayConfirm, 1);
        #                    }
        #                }
        #                else
        #                {
        #                    if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GroupPutaway)
        #                    {
        #                        pass.insert(#GroupPutawayFail, 1);
        #                    }
        #
        #                    ret = this.buildPut(ret, '');
        #                    step = #Put;
        #                }
        #                break;
        #
        #            case WHSWorkType::Custom:
        #                pass.insert(#CustomCode, workLine.WorkTypeCustomCode);
        #                ret = this.buildConfirmScreen(ret, WHSWorkTypeCustom::find(workLine.WorkTypeCustomCode).WorkTypeCustomDesc);
        #                step = #CustomConfirmation;
        #                break;
        #
        #            case WHSWorkType::StatusChange:
        #                if (!WHSWorkTypeStatusChange::find(workLine.statusChangeCode()).PromptUser)
        #                {
        #                    WHSWorkQuarantine::changeLPStatusByWorkLine(workLine, WHSWorkTypeStatusChange::find(workLine.statusChangeCode()).InventStatusId);
        #                    workLine = workExecute.confirmCustomWork(workLine.WorkId, workLine.LineNum, userId);
        #                    ret = this.determineRestart(con);
        #                    if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
        #                    {
        #                        throw error("@WAX1459");
        #                    }
        #                    recall = true;
        #                }
        #                else
        #                {
        #                    step = #StatusChange;
        #                }
        #                break;
        #
        #            case WHSWorkType::Print:
        #                workLine = workExecute.confirmCustomWork(workLine.WorkId, workLine.LineNum, userId);
        #                labelBuild = new WHSLicensePlateLabelBuild(workLine.WorkId, workLine, '', pass.lookup(#UserId));
        #                labelBuild.buildLicensePlateLabels();
        #                ret = this.determineRestart(con);
        #                if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
        #                {
        #                    throw error("@WAX1459");
        #                }
        #                recall = true;
        #                break;
        #
        #            default:
        #                ret = this.addErrorLabel(ret, "@GOA103");
        #                ret = this.buildGetWorkId(ret);
        #                break;
        #        }
        #    }
        #
        #    pass.remove(#DetermineStep);
        #
        #    return [ret, recall];
        #}
      ENDSOURCE
      SOURCE #getWorkExecuteModeFromWorkTransType
        #WHSWorkExecuteMode getWorkExecuteModeFromWorkTransType(
        #    WHSWorkTransType  _workTransType,
        #    WHSLicensePlateId _targetLicensePlateId)
        #{
        #    WHSWorkExecuteMode      workExecuteMode;
        #
        #    switch (_workTransType)
        #    {
        #        case WHSWorkTransType::TransferIssue,
        #             WHSWorkTransType::Sales:
        #            workExecuteMode = WHSWorkExecuteMode::Shipping;
        #            break;
        #
        #        case WHSWorkTransType::Purch, WHSWorkTransType::TransferReceipt:
        #            workExecuteMode = _targetLicensePlateId ? WHSWorkExecuteMode::PurchaseOrderLine : WHSWorkExecuteMode::ASNLicensePlate;
        #            break;
        #
        #        case WHSWorkTransType::ProdPick:
        #            workExecuteMode = WHSWorkExecuteMode::RawMaterialPicking;
        #            break;
        #
        #        case WHSWorkTransType::ProdPut:
        #        case WHSWorkTransType::ProdProcessPut:
        #        case WHSWorkTransType::KanbanPut:
        #            workExecuteMode = WHSWorkExecuteMode::FinishedGoodsPutaway;
        #            break;
        #
        #        case WHSWorkTransType::KanbanPick:
        #            workExecuteMode = WHSWorkExecuteMode::RawMaterialPicking;
        #            break;
        #
        #        case WHSWorkTransType::Invent:
        #        case WHSWorkTransType::CycleCountAccepted:
        #            workExecuteMode = WHSWorkExecuteMode::Movement;
        #            break;
        #
        #        case WHSWorkTransType::Replenishment,
        #             WHSWorkTransType::ReturnOrder:
        #            workExecuteMode = WHSWorkExecuteMode::UserDirected;
        #            break;
        #
        #        default:
        #            throw error("@WAX867");
        #    }
        #
        #    return workExecuteMode;
        #}
      ENDSOURCE
      SOURCE #hasComments
        #boolean hasComments()
        #{
        #    WHSShipmentTable    shipmentTable;
        #    DocuRef             docuRef;
        #    WHSWorkLine         pickLine;
        #    WHSWorkLine         firstPutLine;
        #    boolean             ret;
        #    WHSParameters       parameters = WHSParameters::find();
        #
        #    select firstonly LineNum, WorkId from firstPutLine
        #        order by LineNum desc
        #        where firstPutLine.WorkId   == workLine.WorkId &&
        #              firstPutLine.WorkType == WHSWorkType::Put;
        #
        #    select firstonly LineNum, WorkId, ShipmentId from pickLine
        #        order by LineNum desc
        #        join ShipmentId, TableId, RecId from shipmentTable
        #        where pickLine.LineNum      <  firstPutLine.LineNum &&
        #              pickLine.WorkId       == firstPutLine.WorkId  &&
        #              pickLine.ShipmentId   == shipmentTable.ShipmentId
        #            join docuRef
        #            where docuRef.RefTableId    == shipmentTable.TableId    &&
        #                  docuRef.RefRecId      == shipmentTable.RecId      &&
        #                  docuRef.TypeId        == parameters.rfNoteType;
        #
        #    if (docuRef)
        #    {
        #        ret = true;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #hasError
        #int hasError(container _con)
        #{
        #    int     length;
        #    int     ret;
        #    int     i = 3
        #    ;
        #
        #    length = conLen(_con);
        #
        #    while (i <= length)
        #    {
        #        if (conPeek(conPeek(_con, i), #controlType) == #RFLabel &&
        #            conPeek(conPeek(_con, i), #name) == #RFError)
        #        {
        #            ret = 1;
        #            break;
        #        }
        #
        #        ++i;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #initInventDimFromPassDimList
        #/// <summary>
        #/// Initializes an <c>InventDim</c> buffer from the current dimensions list.
        #/// </summary>
        #/// <param name="_inventDim">
        #/// The <c>InventDim</c> buffer that should be initialized.
        #/// </param>
        #/// <param name="_dimList">
        #/// The list of dimension field ID's that should be assigned values.
        #/// </param>
        #/// <remarks>
        #/// This method relies on the keys of the pass through map to match inventDim field names.
        #/// </remarks>
        #protected void initInventDimFromPassDimList(
        #    InventDim   _inventDim,
        #    List        _dimList)
        #{
        #    ListEnumerator  enumerator;
        #    FieldName       fieldName;
        #
        #    enumerator = _dimList.getEnumerator();
        #
        #    while (enumerator.moveNext())
        #    {
        #        fieldName = fieldId2name(_inventDim.TableId, enumerator.current());
        #
        #        if (pass.hasValue(fieldName))
        #        {
        #            _inventDim.(enumerator.current()) = pass.lookup(fieldName);
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #initVendBatchInfoFields
        #/// <summary>
        #///     Initialize the vendor batch detail fields within the pass.
        #/// </summary>
        #protected void initVendBatchInfoFields()
        #{
        #    InventBatch                     inventBatch;
        #    PurchLine                       purchLine;
        #    WHSInventBatchReceiptDetails    whsInventBatchReceiptDetails;
        #    PdsVendBatchDate                vendBatchDate;
        #    PdsVendExpiryDate               vendExpiryDate;
        #    str                             useVendBatchDate;
        #    str                             useVendExpiryDate;
        #    PdsCountryOfOrigin              countryOfOrigin1;
        #    PdsCountryOfOrigin1             countryOfOrigin2;
        #    PdsVendBatchId                  vendBatchId;
        #    PdsVendBatchInfo                pdsVendBatchInfo;
        #
        #    whsInventBatchReceiptDetails = WHSInventBatchReceiptDetails::find(pass.lookupStr(#ReceiptId), pass.lookupStr(#ItemId), pass.lookupStr(#BatchId));
        #
        #    if (whsInventBatchReceiptDetails.RecId > 0)
        #    {
        #        vendBatchDate       = whsInventBatchReceiptDetails.PdsVendBatchDate;
        #        useVendBatchDate    = enum2str(whsInventBatchReceiptDetails.PdsUseVendBatchDate);
        #        vendExpiryDate      = whsInventBatchReceiptDetails.PdsVendExpiryDate;
        #        useVendExpiryDate   = enum2str(whsInventBatchReceiptDetails.PdsUseVendBatchExp);
        #        countryOfOrigin1    = whsInventBatchReceiptDetails.PdsCountryOfOrigin1;
        #        countryOfOrigin2    = whsInventBatchReceiptDetails.PdsCountryOfOrigin2;
        #        vendBatchId         = whsInventBatchReceiptDetails.PdsVendBatchId;
        #    }
        #    else
        #    {
        #        inventBatch = InventBatch::find(pass.lookupStr(#BatchId), pass.lookupStr(#ItemId));
        #
        #        if (inventBatch.RecId > 0)
        #        {
        #            vendBatchDate       = inventBatch.PdsVendBatchDate;
        #            useVendBatchDate    = enum2str(inventBatch.PdsUseVendBatchDate);
        #            vendExpiryDate      = inventBatch.PdsVendExpiryDate;
        #            useVendExpiryDate   = enum2str(inventBatch.PdsUseVendBatchExp);
        #            countryOfOrigin1    = inventBatch.PdsCountryOfOrigin1;
        #            countryOfOrigin2    = inventBatch.PdsCountryOfOrigin2;
        #            vendBatchId         = inventBatch.PdsVendBatchId;
        #        }
        #        else
        #        {
        #            purchLine           = PurchLine::find(pass.lookupStr(#PONum), pass.lookupInt64(#POLineNum));
        #            pdsVendBatchInfo    = PdsVendBatchInfo::findByRefRecId(purchLine.RecId);
        #
        #            if (pdsVendBatchInfo.RecId > 0)
        #            {
        #                vendBatchDate       = pdsVendBatchInfo.VendBatchDate;
        #                useVendBatchDate    = enum2str(pdsVendBatchInfo.UseVendBatchDate);
        #                vendExpiryDate      = pdsVendBatchInfo.VendExpiryDate;
        #                useVendExpiryDate   = enum2str(pdsVendBatchInfo.UseVendBatchExp);
        #                countryOfOrigin1    = pdsVendBatchInfo.CountryOfOrigin1;
        #                countryOfOrigin2    = pdsVendBatchInfo.CountryOfOrigin2;
        #                vendBatchId         = pdsVendBatchInfo.VendBatchId;
        #            }
        #        }
        #    }
        #
        #    pass.insert(#VendBatchDate, vendBatchDate);
        #    pass.insert(#UseVendBatchDate, useVendBatchDate);
        #    pass.insert(#VendExpDate, vendExpiryDate);
        #    pass.insert(#UseVendExpDate, useVendExpiryDate);
        #    pass.insert(#CountryOfOrigin1, countryOfOrigin1);
        #    pass.insert(#CountryOfOrigin2, countryOfOrigin2);
        #    pass.insert(#VendBatchId, vendBatchId);
        #}
      ENDSOURCE
      SOURCE #isOnHandGreaterThanDemand
        #/// <summary>
        #/// Method determines if on hand inventory for specific dimension set is greater than current work demand.
        #/// </summary>
        #/// <param name="_inventDim">
        #/// The dimension set used for finding on hand inventory
        #/// </param>
        #/// <param name="_itemId">
        #/// The Id of the item which we are evaluating on hand inventory.
        #/// </param>
        #/// <param name="_qtyToBePicked">
        #/// The qty remaining to be picked.
        #/// </param>
        #/// <returns>
        #/// true if on hand inventory is greater than work demand; otherwise false
        #/// </returns>
        #private boolean isOnHandGreaterThanDemand(
        #    InventDim   _inventDim,
        #    ItemId      _itemId,
        #    InventQty   _qtyToBePicked)
        #{
        #    InventDim   inventDim = _inventDim;
        #
        #    inventDim = InventDim::findOrCreate(inventDim);
        #
        #    return WHSInventOnHand::getWorkPhysicalInvent(_itemId, inventDim.InventDimId) > _qtyToBePicked;
        #}
      ENDSOURCE
      SOURCE #populateItemBatchReceiptDetails
        #/// <summary>
        #///     Populates the <c>WHSInventBatchReceiptDetails</c> table with details from the received batch.
        #/// </summary>
        #protected void populateItemBatchReceiptDetails()
        #{
        #    WHSInventBatchReceiptDetails    whsInventBatchReceiptDetails;
        #    InventTable                     inventTable;
        #
        #    ttsbegin;
        #
        #    inventTable = InventTable::find(pass.lookup(#ItemId));
        #
        #    whsInventBatchReceiptDetails = WHSInventBatchReceiptDetails::find(pass.lookup(#ReceiptId), inventTable.ItemId, pass.lookup(#BatchId), true);
        #
        #    if (whsInventBatchReceiptDetails.RecId == 0)
        #    {
        #        whsInventBatchReceiptDetails.ReceiptId      = pass.lookup(#ReceiptId);
        #        whsInventBatchReceiptDetails.ItemId         = inventTable.ItemId;
        #        whsInventBatchReceiptDetails.InventBatchId  = pass.lookup(#BatchId);
        #    }
        #
        #    // For shelf life items, the expiration date will be calculated at registration.
        #    if (!inventTable.isShelfLifeItem())
        #    {
        #        whsInventBatchReceiptDetails.ExpDate = str2Date(pass.lookup(#ExpDate), 213);
        #    }
        #
        #    if (pass.exists(#VendBatchInfoEntered))
        #    {
        #        whsInventBatchReceiptDetails.PdsVendBatchDate       = str2Date(pass.lookup(#VendBatchDate), 213);
        #        whsInventBatchReceiptDetails.PdsUseVendBatchDate    = pass.lookup(#UseVendBatchDate) == enum2str(NoYes::Yes) ? NoYes::Yes : NoYes::No;
        #        whsInventBatchReceiptDetails.PdsVendExpiryDate      = str2Date(pass.lookup(#VendExpDate), 213);
        #        whsInventBatchReceiptDetails.PdsUseVendBatchExp     = pass.lookup(#UseVendExpDate) == enum2str(NoYes::Yes) ? NoYes::Yes : NoYes::No;
        #        whsInventBatchReceiptDetails.PdsCountryOfOrigin1    = pass.lookup(#CountryOfOrigin1);
        #        whsInventBatchReceiptDetails.PdsCountryOfOrigin2    = pass.lookup(#CountryOfOrigin2);
        #        whsInventBatchReceiptDetails.PdsVendBatchId         = pass.lookup(#VendBatchId);
        #    }
        #
        #    whsInventBatchReceiptDetails.PdsPotencyBaseValue        = pass.lookupStr(#Potency);
        #    whsInventBatchReceiptDetails.PdsBatchDispositionCode    = pass.lookupStr(#BatchDisposition);
        #
        #    whsInventBatchReceiptDetails.write();
        #
        #    ttscommit;
        #}
      ENDSOURCE
      SOURCE #processFieldValues
        #container processFieldValues(container _con, WHSRFPassthrough _fieldValues)
        #{
        #    str         value;
        #    boolean     complete = true;
        #    container   con = _con;
        #    str         controlType;
        #    str         name;
        #    int         length;
        #    int         i;
        #    int         enabled;
        #
        #    length = conLen(con);
        #
        #    for (i = 1; i <= length; ++i)
        #    {
        #        controlType = conPeek(conPeek(con, i), #controlType);
        #
        #        if (controlType == #RFText      ||
        #            controlType == #RFPassword)
        #        {
        #            name = conPeek(conPeek(con, i), #name);
        #
        #            if (_fieldValues.exists(name))
        #            {
        #                con = conPoke(con, i, conPoke(conPeek(con, i), #data, _fieldValues.lookup(name)));
        #
        #                value   = _fieldValues.lookup(name);
        #                enabled = conPeek(conPeek(con, i), #enabled);
        #
        #                if (!str2numOK(value)
        #                &&  !value
        #                &&  enabled)
        #                {
        #                    complete = false;
        #                }
        #            }
        #        }
        #        else if (controlType == #RFComboBox && conPeek(conPeek(con, i), #data) == '' && conPeek(conPeek(con,i), #selected) == '')
        #        {
        #            name    = conPeek(conPeek(con, i), #name);
        #            enabled = conPeek(conPeek(con, i), #enabled);
        #
        #            if (name    != #Disposition
        #            &&  name    != #InventoryStatus
        #            &&  enabled)
        #            {
        #                complete = false;
        #            }
        #        }
        #    }
        #
        #    return [con, complete];
        #}
      ENDSOURCE
      SOURCE #processWorkLine
        #container processWorkLine(WHSWorkLine           _workLine,
        #                          container             _con,
        #                          WHSWorkExecuteMode    _mode,
        #                          int                   _step,
        #                          WHSUserId             _userId,
        #                          WMSLocationId         _newLocationId = '',
        #                          str                   _buttonClicked = '',
        #                          boolean               _looping = true)
        #{
        #    WMSLocationId                   locationId;
        #    WHSLicensePlateLabelBuild       labelBuild;
        #    WHSWorkExecute                  workExecute = new WHSWorkExecute();
        #    container                       ret = conNull();
        #    container                       con = _con;
        #    int                             prevStep = _step;
        #    int                             hasError = 0;
        #    boolean                         recall;
        #    container                       tmpFieldValues;
        #    boolean                         complete;
        #    boolean                         isPutBefore;
        #    Map                             fieldValues = new Map(Types::String, Types::String);
        #    Map                             globalPass;
        #    WHSWorkId                       tmpWorkId;
        #    WHSWorkGroupingId               groupingId;
        #    WHSRFAutoConfirm                autoConfirm;
        #    WHSWorkLine                     preWorkLine = workLine;
        #    WHSWorkLine                     tmpWorkLine;
        #    WHSWorkLineCustom               workLineCustom;
        #    WHSParameters                   parameters;
        #    WHSToteReuseTable               toteReuseTable;
        #    WHSWorkGrouping                 workGrouping;
        #    WHSAnchor                       anchor;
        #    WHSCycleCountThresholdId        cycleCountThresholdId;
        #    WHSWorkId                       cycleCountWorkId;
        #    WHSWorkExecuteDisplayCycleCount workExecuteDisplayCycleCount;
        #    boolean                         groupPutawayFail;
        #    WHSAuditSeqNum                  auditSeqNum;
        #    boolean                         auditComplete;
        #    WHSWorkAuditTemplateLine        workAuditTemplateLine;
        #    WHSWorkAuditCaptureData         workAuditCaptureData;
        #    WHSTargetLicensePlateId         targetLicensePlateId;
        #    int                             startInfologLine;
        #    WHSRFMenuItemTable              menuItemTable;
        #    WHSOverrideTargetLP             overrideTargetLP;
        #    WHSWorkTypeCustom               workTypeCustom;
        #    WHSData                         data;
        #    str                             validateUserDirectField;
        #
        #    globalPass = pass;
        #    pass = WHSRFPassthrough::create(conPeek(_con, 2));
        #    pass = this.combineMaps(globalPass, pass);
        #
        #    if (pass.exists(#AutoConfirm))
        #    {
        #        pass.remove(#AutoConfirm);
        #    }
        #
        #    if (pass.exists(#MenuItem))
        #    {
        #        menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));
        #
        #        anchor = menuItemTable.Anchor;
        #        overrideTargetLP = menuItemTable.OverrideTargetLP;
        #    }
        #
        #    if (workLine.isFirstWorkLine()                          &&
        #        (!pass.exists(#AuditWorkId)                         ||
        #         pass.lookup(#AuditWorkId) != workLine.WorkId)   &&
        #        WHSWorkAuditTemplateTable::evaluateWorkAuditBreak(WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).WorkAuditTemplateId,
        #                                                          workTable,
        #                                                          pass.lookup(#MenuItem),
        #                                                          WHSAuditBreakEvent::Prior,
        #                                                          pass.lookupStr(#WorkGroupingId)))
        #    {
        #        if (pass.exists(#DetermineStep))
        #        {
        #            pass.remove(#DetermineStep);
        #        }
        #
        #        step  = #WorkAuditTemplate;
        #        recall = true;
        #        pass.insert(#AuditWorkId, workLine.WorkId);
        #    }
        #
        #    if (workLine.isFirstWorkLine() && _looping)
        #    {
        #        workExecute.updateWorkStatus(workLine.WorkId, workLine.LineNum, userId);
        #        step = conPeek(conPeek(ret, 1), 2);
        #        pass = new WHSRFPassthrough(Types::String, Types::String);
        #        pass = WHSRFPassthrough::create(conPeek(ret, 2));
        #    }
        #    else if (pass.exists(#DetermineStep))
        #    {
        #        workExecute.updateWorkStatus(workLine.WorkId, workLine.LineNum, userId);
        #        [ret, recall] = this.getStep(con, _mode);
        #        pass.insert(#AutoConfirm, 1);
        #    }
        #    else
        #    {
        #        hasError = this.hasError(con);
        #
        #        if (step)
        #        {
        #            try
        #            {
        #                startInfologLine = infologLine() + 1;
        #                if (hasError)
        #                {
        #                    con = conDel(con, 3, 1);
        #                    con = this.clearErrors(con);
        #                }
        #
        #                if (step != #OverrideStep1 && step != #OverrideStep2 && step != #NoLocation &&
        #                    step != #ReceivingExceptionStep1 && step != #ReceivingExceptionStep2    &&
        #                    step != #SplitWork && step != #ShortPick && step != #ShortPickConf      &&
        #                    step != #RFPickingComment && step != #AssignSerialStep && step != #WorkAuditTemplate)
        #                {
        #                    if (step == #Pick)
        #                    {
        #                        if (!this.validateNonSerialInventory(workLine))
        #                        {
        #                            throw error("@WAX5563");
        #                        }
        #                    }
        #
        #                    [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
        #                    fieldValues = WHSRFPassthrough::create(tmpFieldValues);
        #                    pass = this.combineMaps(pass, fieldValues);
        #                    [ret, complete] = this.processFieldValues(con, fieldValues);
        #
        #                    if (!complete)
        #                    {
        #                        if (pass.exists(#TargetLicensePlateId) && pass.lookup(#TargetLicensePlateId) == '')
        #                        {
        #                            pass.remove(#TargetLicensePlateId);
        #                        }
        #
        #                        return [ret, step, recall, pass.pack()];
        #                    }
        #                    else if (InventTable::find(workLine.ItemId).whsSerialActive()                               &&
        #                             WHSInventTable::captureSerial(workLine.ItemId) == WHSRFWhenToCapture::Picking      &&
        #                             workTable.WorkTransType                    == WHSWorkTransType::Sales              &&
        #                             workLine.WorkType                           == WHSWorkType::Pick                   &&
        #                             !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum)                       &&
        #                             !pass.exists(#AssignSerial))
        #                    {
        #                        pass.insert(#AssignSerial, 1);
        #                        pass.insert(#SerialCounter, 1);
        #                        pass.insert(#SerialQty, this.getSerialItemQty(pass.lookupStr(#LicensePlateId)));
        #                        step = #AssignSerialStep;
        #                        ret = conNull();
        #                        ret = this.buildAssignSerial(ret);
        #                        return [ret, step, recall, pass.pack()];
        #                    }
        #                }
        #            }
        #            catch
        #            {
        #                ret = conNull();
        #                ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                con = conDel(con, 1, 2);
        #                ret += con;
        #                return [ret, step, recall, pass.pack()];
        #            }
        #        }
        #
        #        startInfologLine = infologLine() + 1;
        #        switch (_step)
        #        {
        #            case #Pick:
        #                try
        #                {
        #                    this.buildPick(ret, '', false);
        #
        #                    if (pass.exists(#DimPrompt))
        #                    {
        #                        ret = conNull();
        #                        ret = this.buildPick(ret, '', false);
        #                        pass.remove(#DimPrompt);
        #                        break;
        #                    }
        #
        #                    targetLicensePlateId = workLine.whsWorkTable().TargetLicensePlateId;
        #
        #                    isPutBefore = WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum);
        #
        #                    if ((pass.exists(#LicensePlateId) && pass.lookup(#LicensePlateId) != '') || isPutBefore)
        #                    {
        #                        if (!targetLicensePlateId)
        #                        {
        #                            WHSWorkTable::addTargetLicensePlate(workLine.WorkId, pass.lookup(#LicensePlateId));
        #
        #                            workLine = workExecute.pickLicensePlate(pass.lookup(#LicensePlateId),
        #                                                                    workLine.WorkId,
        #                                                                    workLine.LineNum,
        #                                                                    userId,
        #                                                                    this.createInventDimFromPass(),
        #                                                                    pass.lookup(#LicensePlateId),
        #                                                                    false,
        #                                                                    pass.exists(#AssignSerial) ? true : false,
        #                                                                    overrideTargetLP);
        #                        }
        #                        else if (isPutBefore)
        #                        {
        #                            workLine = workExecute.pickLicensePlate(pass.lookup(#TargetLicensePlateId),
        #                                                                    workLine.WorkId,
        #                                                                    workLine.LineNum,
        #                                                                    userId,
        #                                                                    null);
        #                        }
        #                        else
        #                        {
        #                            if (pass.exists(#TargetLicensePlateId))
        #                            {
        #                                WHSWorkTable::addTargetLicensePlate(workLine.WorkId, pass.lookup(#TargetLicensePlateId));
        #                            }
        #
        #                            workLine = workExecute.pickLicensePlate(pass.lookup(#LicensePlateId),
        #                                                                    workLine.WorkId,
        #                                                                    workLine.LineNum,
        #                                                                    userId,
        #                                                                    this.createInventDimFromPass(),
        #                                                                    pass.lookupStr(#TargetLicensePlateId),
        #                                                                    false,
        #                                                                    pass.exists(#AssignSerial) ? true : false);
        #                        }
        #
        #                        if (workLine.AskForNewLicensePlate)
        #                        {
        #                            ret = conNull();
        #                            ret = this.buildPick(ret);
        #
        #                            if (workTable.WorkTransType == WHSWorkTransType::Invent  &&
        #                                pass.exists(#TargetLicensePlateId))
        #                            {
        #                                pass.remove(#TargetLicensePlateId);
        #                            }
        #
        #                            recall = false;
        #                        }
        #                    }
        #                    else
        #                    {
        #                        workLine = workExecute.pickNonLicensePlateCheckDigit(workLine.WorkId,
        #                                                                             workLine.LineNum,
        #                                                                             workLine.ItemId,
        #                                                                             workLine.QtyRemain,
        #                                                                             workLine.UnitId,
        #                                                                             userId,
        #                                                                             this.createInventDimFromPass(),
        #                                                                             pass.lookupStr(#TargetLicensePlateId),
        #                                                                             pass.exists(#AssignSerial) ? true : false);
        #                        if (pass.exists(#TargetLicensePlateId))
        #                        {
        #                            WHSWorkTable::addTargetLicensePlate(workLine.WorkId, pass.lookup(#TargetLicensePlateId));
        #                        }
        #                    }
        #
        #                    if (!workLine.AskForNewLicensePlate)
        #                    {
        #                        ret = this.determineRestart(con);
        #
        #                        if (pass.exists(#AssignSerial))
        #                        {
        #                            pass.remove(#AssignSerial);
        #                        }
        #                    }
        #
        #                    if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
        #                    {
        #                        throw error("@WAX1459");
        #                    }
        #                    if (!workLine.AskForNewLicensePlate)
        #                    {
        #                        recall = true;
        #                    }
        #
        #                    // If pick completed and menu item allows, evaluate cycle count thresholds
        #                    if (!WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).DisableCycleCountThreshold && preWorkLine.LineNum != workLine.LineNum)
        #                    {
        #                        cycleCountThresholdId = WHSCycleCountCreateThreshold::processCycleCountThreshold(preWorkLine.WorkId, preWorkLine.LineNum);
        #
        #                        // Check to see if an immediate count needs to be executed
        #                        if (WHSCycleCountThreshold::find(cycleCountThresholdId).ImmediateCycleCount)
        #                        {
        #                            // Find open cycle count work for the location
        #                            cycleCountWorkId = WHSWorkTable::findCycleCountByLocation(WHSWorkUserSession::find(userId).InventLocationId, preWorkLine.wmsLocationId);
        #
        #                            if (cycleCountWorkId)
        #                            {
        #                                if (step == #StepOne)
        #                                {
        #                                    step = WHSCycleCountThreshold::getImmediateCountStep(WHSRFMenuItemTable::getWHSWorkExecuteMode(WHSRFMenuItemTable::find(pass.lookup(#MenuItem))));
        #                                    pass.insert(#DetermineStep, 1);
        #                                    pass.insert(#Recall, 1);
        #                                }
        #
        #                                // Store off passthrough to be used after count is complete
        #                                WHSWorkUserSession::setPrevPass(pass.lookup(#UserId), pass.pack());
        #
        #                                pass = this.resetPassthrough(ret, false);
        #                                pass.insert(#WorkId, cycleCountWorkId);
        #                                pass.insert(#LineNum, 1);
        #                                pass.insert(#PrevCountStep, step);
        #                                step = 0;
        #                                recall = false;
        #
        #                                workExecuteDisplayCycleCount = WHSWorkExecuteDisplayCycleCount::construct();
        #                                ret = conDel(ret, 1, 2);
        #                                ret = this.updateModeStepPass(ret, mode, step, pass);
        #                                ret = workExecuteDisplayCycleCount.displayForm(ret, _buttonClicked);
        #                                pass = WHSRFPassthrough::create(conPeek(ret, 2));
        #                            }
        #                        }
        #                    }
        #                }
        #                catch
        #                {
        #                    if (workLine.WorkType == WHSWorkType::Pick)
        #                    {
        #                        pass.remove(#LicensePlateId);
        #                    }
        #
        #                    if (workLine.AskForNewLicensePlate
        #                    ||  (!targetLicensePlateId
        #                    &&   workLine.whsWorkTable().TargetLicensePlateId))
        #                    {
        #                        WHSWorkTable::addTargetLicensePlate(workLine.WorkId, '');
        #                    }
        #
        #                    ret = conNull();
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                    ret = this.buildPick(ret, '');
        #                }
        #                break;
        #
        #            case #Put:
        #                try
        #                {
        #                    if (workLine.WorkType == WHSWorkType::Put && pass.lookup(#WMSLocationId) != workLine.wmsLocationId)
        #                    {
        #                        ret = conNull();
        #                        ret = this.addErrorLabel(ret, "@WAX2962", WHSRFColorText::Error);
        #                        ret = this.buildPut(ret);
        #                        step = #Put;
        #                        break;
        #                    }
        #
        #                    parameters = WHSParameters::find();
        #
        #                    tmpWorkLine = WHSWorkLine::getPrevOppositeWorkLine(workLine.WorkId,
        #                                                                       workLine.LineNum,
        #                                                                       workLine.WorkType);
        #
        #                    if (anchor && !workLine.IsAnchored)
        #                    {
        #                        workExecute.anchorWork(pass.lookup(#WorkId), workLine.wmsLocationId, workLine.wmsLocationId, WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).AnchorBy);
        #                    }
        #
        #                    if (pass.exists(#TargetLicensePlateId))
        #                    {
        #                        // Check to see if the early tote reuse is turned on and we are putting to a packing station
        #                        if (parameters.ToteReuse && workLine.getLocationProfileId() == parameters.PackingLocType)
        #                        {
        #                            // Create a record in the toteReuseTable
        #                            toteReuseTable = WHSToteReuseTable::addNewRecord(workLine.WorkId, pass.lookup(#TargetLicensePlateId));
        #                            // Change the LicensePlate passthrough to the newly generated LicensePlateId.
        #                            pass.insert(#TargetLicensePlateId, toteReuseTable.TmpToteId);
        #                        }
        #
        #                        // Close work's container
        #                        if (!WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum))
        #                        {
        #                            WHSContainerTable::determineContainerClose(workLine.WorkId);
        #                        }
        #
        #                        workLine = workExecute.putAwayToLocation(workLine.WorkId,
        #                                                                 workLine.LineNum,
        #                                                                 workLine.wmsLocationId,
        #                                                                 tmpWorkLine.InventQtyWork > workLine.InventQtyWork ? WHSWorkPutFlow::SplitQuantity :
        #                                                                                                                      WHSWorkPutFlow::MoveAll,
        #                                                                 userId,
        #                                                                 pass.lookupStr(#LicensePlateId),
        #                                                                 pass.lookupStr(#TargetLicensePlateId));
        #                    }
        #                    else
        #                    {
        #                        // Check to see if the early tote reuse is turned on and we are putting to a packing station
        #                        if (parameters.ToteReuse && workLine.getLocationProfileId() == parameters.PackingLocType)
        #                        {
        #                            // Create a record in the toteReuseTable
        #                            toteReuseTable = WHSToteReuseTable::addNewRecord(workLine.WorkId, pass.lookup(#LicensePlateId));
        #                            // Change the LicensePlate passthrough to the newly generated LicensePlateId.
        #                            pass.insert(#LicensePlateId, toteReuseTable.TmpToteId);
        #                        }
        #
        #                        // Close work's container
        #                        if (!WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum))
        #                        {
        #                            WHSContainerTable::determineContainerClose(workLine.WorkId);
        #                        }
        #
        #                        workLine = workExecute.putAwayToLocation(workLine.WorkId,
        #                                                                 workLine.LineNum,
        #                                                                 workLine.wmsLocationId,
        #                                                                 tmpWorkLine.InventQtyWork > workLine.InventQtyWork ? WHSWorkPutFlow::SplitQuantity :
        #                                                                                                                      WHSWorkPutFlow::MoveAll,
        #                                                                 userId,
        #                                                                 pass.lookupStr(#SourceLicensePlateId),
        #                                                                 pass.lookupStr(#LicensePlateId));
        #                    }
        #
        #                    if (pass.exists(#WorkId))
        #                    {
        #                        tmpWorkId = pass.lookup(#WorkId);
        #                    }
        #                    if (pass.exists(#WorkGroupingId))
        #                    {
        #                        groupingId = pass.lookup(#WorkGroupingId);
        #                    }
        #                    if (pass.exists(#GroupPutawayFail))
        #                    {
        #                        groupPutawayFail = true;
        #                    }
        #
        #                    validateUserDirectField = pass.lookupStr(#ValidateUserDirectField);
        #                    ret = this.determineRestart(con);
        #                    if (pass.lookupStr(#ValidateUserDirectField) == "")
        #                    {
        #                        pass.insert(#ValidateUserDirectField, validateUserDirectField);
        #                    }
        #
        #                    if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
        #                    {
        #                        throw error("@WAX1459");
        #                    }
        #
        #                    recall = true;
        #
        #                    pass.insert(#PrevWorkId, tmpWorkId);
        #                    pass.insert(#WorkGroupingId, groupingId);
        #
        #                    if (groupPutawayFail)
        #                    {
        #                        pass.insert(#GroupPutawayFail, 1);
        #                    }
        #                }
        #                catch
        #                {
        #                    ret = conNull();
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                    ret = this.buildPut(ret, '');
        #                }
        #                break;
        #
        #            case #CustomConfirmation:     // Custom Work Confirmation
        #                try
        #                {
        #                    workTypeCustom = WHSWorkTypeCustom::find(workLine.WorkTypeCustomCode);
        #
        #                    if (workTypeCustom.CaptureData)
        #                    {
        #                        data = conPeek(conPeek(con, 4), #data);
        #                        if (!data)
        #                        {
        #                            // With CaptureData set to Yes data is required
        #                            throw error("@WAX1080");
        #                        }
        #                        workLineCustom.WorkId   = workLine.WorkId;
        #                        workLineCustom.LineNum  = workLine.LineNum;
        #                        workLineCustom.rfLabel  = WHSWorkTypeCustom::find(workLine.WorkTypeCustomCode).rfLabel;
        #                        workLineCustom.Data     = data;
        #                        workLineCustom.insert();
        #                    }
        #
        #                    // Actual custom method invocation.
        #                    if (workTypeCustom.WorkTypeCustomMethod)
        #                    {
        #                        WHSWorkTypeCustom::callCustomMethod(workTypeCustom.WorkTypeCustomMethod, workLine.WorkId, data);
        #                    }
        #
        #                    tmpWorkId = workLine.WorkId;
        #                    workLine = workExecute.confirmCustomWork(pass.lookup(#WorkId), pass.lookupNum(#LineNum), userId);
        #                    ret = this.determineRestart(con);
        #                    if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
        #                    {
        #                        throw error("@WAX1459");
        #                    }
        #
        #                    recall = true;
        #                }
        #                catch
        #                {
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                    ret = this.buildConfirmScreen(ret, WHSWorkTypeCustom::find(WHSWorkLine::find(pass.lookup(#WorkId), pass.lookupNum(#LineNum)).WorkTypeCustomCode).WorkTypeCustomDesc);
        #                }
        #                break;
        #
        #            case #StatusChange: // Status Change
        #                try
        #                {
        #                    WHSWorkQuarantine::changeLPStatusByWorkLine(workLine, WHSWorkTypeStatusChange::find(workLine.statusChangeCode()).InventStatusId);
        #                    workLine = workExecute.confirmCustomWork(pass.lookup(#WorkId), pass.lookupNum(#LineNum), userId);
        #                    ret = this.determineRestart(con);
        #                    if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
        #                    {
        #                        throw error("@WAX1459");
        #                    }
        #
        #                    recall = true;
        #                }
        #                catch
        #                {
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                }
        #                break;
        #
        #            case #Print:     // Print
        #                try
        #                {
        #                    if (!pass.exists(#Confirmation))
        #                    {
        #                        labelBuild = new WHSLicensePlateLabelBuild(pass.lookup(#WorkId), WHSWorkLine::find(pass.lookup(#WorkId), pass.lookupNum(#LineNum)), '', pass.lookup(#UserId));
        #                        labelBuild.buildLicensePlateLabels();
        #                    }
        #                    else
        #                    {
        #                        pass.remove(#Confirmation);
        #                    }
        #                    workLine = workExecute.confirmCustomWork(pass.lookup(#WorkId), pass.lookupNum(#LineNum), userId);
        #                    ret = this.determineRestart(con);
        #                    if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
        #                    {
        #                        throw error("@WAX1459");
        #                    }
        #                    recall = true;
        #                }
        #                catch
        #                {
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                }
        #                break;
        #
        #            case #NoLocation:     // No Location on Work
        #                try
        #                {
        #                    if (!pass.exists(#NoValidation))
        #                    {
        #                        if (workLine.WorkType == WHSWorkType::Put && pass.lookup(#WMSLocationId) != workLine.wmsLocationId)
        #                        {
        #                            ret = conNull();
        #                            ret = this.addErrorLabel(ret, "@WAX2962", WHSRFColorText::Error);
        #                            ret = this.buildPut(ret);
        #                            if (pass.exists(#NoOverrideButton))
        #                            {
        #                                pass.remove(#NoOverrideButton);
        #                            }
        #                            pass.insert(#WMSLocationId, workLine.wmsLocationId);
        #                            step = #Put;
        #                            break;
        #                        }
        #
        #                        pass.insert(#WMSLocationId, conPeek(conPeek(con, 4), #data));
        #
        #                        if (pass.lookup(#WMSLocationId) == '')
        #                        {
        #                            pass.insert(#WMSLocationId, workLine.wmsLocationId);
        #                            throw error("@WAX1160");
        #                        }
        #
        #                        locationId = workExecute.convertWMSLocationId(WHSWorkUserSession::find(userId).InventLocationId, pass.lookup(#WMSLocationId));
        #                        if (!locationId)
        #                        {
        #                            pass.insert(#WMSLocationId, workLine.wmsLocationId);
        #                            throw error("@WAX755");
        #                        }
        #                        else
        #                        {
        #                            pass.insert(#WMSLocationId, locationId);
        #                        }
        #
        #                        if (workLine.WorkType == WHSWorkType::Put    &&
        #                            !workExecute.validateLocationChange(WHSWorkUserSession::find(userId).InventLocationId, pass.lookup(#WMSLocationId), pass.lookup(#ItemId), _workLine))
        #                        {
        #                            pass.insert(#WMSLocationId, workLine.wmsLocationId);
        #                            throw error("@WAX755");
        #                        }
        #
        #                        if (pass.exists(#GroupPutaway))
        #                        {
        #                            workExecute.overrideGroupPutaway(pass.lookupStr(#WorkGroupingId),
        #                                                             pass.lookup(#WMSLocationId),
        #                                                             pass.lookup(#UserId),
        #                                                             workLine.WorkId,
        #                                                             workLine.LineNum);
        #
        #                            pass.remove(#GroupPutaway);
        #                        }
        #                        else
        #                        {
        #                            workExecute.updateWorkLineLocation(pass.lookup(#WorkId), pass.lookupNum(#LineNum), pass.lookup(#WMSLocationId), pass.lookup(#UserId));
        #                        }
        #
        #                        if (workLine.WorkType == WHSWorkType::Put && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GroupPutaway)
        #                        {
        #                            pass.insert(#PrevStep, #OverrideStep2);
        #                        }
        #
        #                        // Begin achoring if needed
        #                        if (anchor)
        #                        {
        #                            workExecute.anchorWork(pass.lookup(#WorkId),
        #                                                   pass.lookup(#WMSLocationId),
        #                                                   pass.lookupStr(#OverrideFromPutLocation),
        #                                                   WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).AnchorBy);
        #                        }
        #
        #                        if (pass.exists(#OverrideFromPutLocation))
        #                        {
        #                            pass.remove(#OverrideFromPutLocation);
        #                        }
        #
        #                        if (mode == WHSWorkExecuteMode::PickPack)
        #                        {
        #                            pass.insert(#PickPackOverride, 1);
        #                        }
        #
        #                        if (pass.exists(#SuggestLocation))
        #                        {
        #                            pass.remove(#SuggestLocation);
        #                        }
        #
        #                        step = #StepOne;
        #                        recall = true;
        #                    }
        #                    else
        #                    {
        #                        if (workLine.WorkType == WHSWorkType::Pick && !_newLocationId && pass.exists(#UserPutLocation))
        #                        {
        #                            ret = this.addErrorLabel(ret, "@WAX2213", WHSRFColorText::Error);
        #                        }
        #                        ret = this.buildGetLocation(ret, '', _newLocationId);
        #                        pass.remove(#NoValidation);
        #                        pass.insert(#UserPutLocation, 1);
        #                    }
        #                }
        #                catch
        #                {
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                    ret = this.buildGetLocation(ret);
        #                    pass.insert(#UserPutLocation, 1);
        #                    pass.insert(#WMSLocationId, workLine.wmsLocationId);
        #                }
        #                break;
        #
        #            case #GetSourceLP:    // Get Source License Plate
        #                try
        #                {
        #                    pass.insert(#SourceLicensePlateId, conPeek(conPeek(con, 4 + hasError), #data));
        #                    if (pass.lookup(#SourceLicensePlateId))
        #                    {
        #                        if (!workExecute.validateChildLicensePlate(pass.lookup(#WorkId), pass.lookupNum(#LineNum), pass.lookup(#SourceLicensePlateId)))
        #                        {
        #                            throw error("@WAX756");
        #                        }
        #                        ret = conPoke(ret, 2, pass.pack());
        #                        step = pass.lookup(#PrevStep);
        #                        recall = true;
        #                    }
        #                    else
        #                    {
        #                        throw error("@WAX756");
        #                    }
        #                }
        #                catch
        #                {
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                    ret = this.buildGetLicensePlate(ret, "@WAX800");
        #                }
        #                break;
        #
        #            case #ReceivingExceptionStep1:     // Get Exception
        #                try
        #                {
        #                    if (pass.exists(#RunningQty))
        #                    {
        #                        pass.remove(#RunningQty);
        #                    }
        #                    if (pass.exists(#QtyReceived))
        #                    {
        #                        pass.remove(#QtyReceived);
        #                    }
        #                    ret = this.buildReceivingExceptions(ret);
        #                    step = #ReceivingExceptionStep2;
        #                }
        #                catch
        #                {
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                    ret = this.buildReceivingExceptions(ret);
        #                }
        #                break;
        #
        #            case #ReceivingExceptionStep2:     // Receiving Exception
        #                try
        #                {
        #                    pass.insert(#ReceivingExceptionDesc, conPeek(conPeek(con, 3 + hasError), #data));
        #                    if (!pass.exists(#PONum))
        #                    {
        #                        pass.insert(#PONum, '');
        #                    }
        #                    if (!pass.exists(#POLineNum))
        #                    {
        #                        pass.insert(#POLineNum, 0);
        #                    }
        #
        #                    if (_buttonClicked == #RFDone) // Done
        #                    {
        #                        step = #StepOne;
        #                        pass.insert(#RebuildForm, '1');
        #                    }
        #                    else    // Next Exception
        #                    {
        #                        workExecute.createReceivingException(WHSUOMStructure::find(pass.lookupStr(#LicensePlateId), WHSModule::Purch),
        #                                                             pass.lookup(#ReceivingExceptionDesc),
        #                                                             _userId,
        #                                                             pass.lookup(#PONum),
        #                                                             pass.lookupNum(#POLineNum));
        #
        #                        ret = this.buildReceivingExceptions(ret);
        #                    }
        #                }
        #                catch
        #                {
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                    ret = this.buildReceivingExceptions(ret);
        #                }
        #                break;
        #
        #            case #OverrideStep1:     // Override
        #                try
        #                {
        #                    if (workLine.WorkType == WHSWorkType::Put && pass.lookup(#WMSLocationId) != workLine.wmsLocationId)
        #                    {
        #                        ret = conNull();
        #                        ret = this.addErrorLabel(ret, "@WAX2962", WHSRFColorText::Error);
        #                        ret = this.buildPut(ret);
        #                        if (pass.exists(#NoOverrideButton))
        #                        {
        #                            pass.remove(#NoOverrideButton);
        #                        }
        #                        pass.insert(#WMSLocationId, workLine.wmsLocationId);
        #                        step = #Put;
        #                        break;
        #                    }
        #
        #                    if (pass.exists(#WriteOverride))
        #                    {
        #                        pass.remove(#WriteOverride);
        #                        pass.insert(#OverrideDesc, conPeek(conPeek(con, 3 + hasError), #data));
        #                        workExecute.createWorkException(pass.lookup(#WorkId), pass.lookupNum(#LineNum), userId, pass.lookup(#OverrideDesc), workLine.wmsLocationId);
        #                    }
        #                    pass.insert(#NoOverrideButton, 1);
        #                    ret = conNull();
        #                    ret = this.buildWorkExceptions(ret);
        #                    step = #OverrideStep2;
        #                }
        #                catch
        #                {
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                    ret = this.buildWorkExceptions(ret);
        #                }
        #                break;
        #
        #            case #OverrideStep2:     // Override
        #                try
        #                {
        #                    if (workLine.WorkType == WHSWorkType::Put && pass.lookup(#WMSLocationId) != workLine.wmsLocationId)
        #                    {
        #                        ret = conNull();
        #                        ret = this.addErrorLabel(ret, "@WAX2962", WHSRFColorText::Error);
        #                        ret = this.buildPut(ret);
        #                        if (pass.exists(#NoOverrideButton))
        #                        {
        #                            pass.remove(#NoOverrideButton);
        #                        }
        #                        pass.insert(#WMSLocationId, workLine.wmsLocationId);
        #                        step = #Put;
        #                        break;
        #                    }
        #
        #                    if (!pass.exists(#SuggestLocation))
        #                    {
        #                        pass.insert(#OverrideDesc, conPeek(conPeek(con, 3 + hasError), #data));
        #                        workExecute.createWorkException(pass.lookup(#WorkId), pass.lookupNum(#LineNum), userId, pass.lookup(#OverrideDesc), workLine.wmsLocationId);
        #                    }
        #                    if (pass.exists(#NoOverrideButton))
        #                    {
        #                        pass.remove(#NoOverrideButton);
        #                    }
        #                    if (workLine.WorkType == WHSWorkType::Pick && !_newLocationId && pass.exists(#PrevStep))
        #                    {
        #                        ret = this.addErrorLabel(ret, "@WAX2213", WHSRFColorText::Error);
        #                    }
        #                    ret = this.buildGetLocation(ret, '', _newLocationId);
        #                    pass.insert(#PrevStep, step);
        #                    step = #NoLocation;
        #
        #                    if (workLine.WorkType == WHSWorkType::Put)
        #                    {
        #                        pass.insert(#OverrideFromPutLocation, workLine.wmsLocationId);
        #                    }
        #                }
        #                catch
        #                {
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                    ret = this.buildWorkExceptions(ret);
        #                }
        #                break;
        #
        #            case #ShortPick:
        #                try
        #                {
        #                    if (!pass.exists(#Initiation))
        #                    {
        #                        [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
        #                        fieldValues = WHSRFPassthrough::create(tmpFieldValues);
        #                        pass = this.combineMaps(pass, fieldValues);
        #                        [ret, complete] = this.processFieldValues(con, fieldValues);
        #
        #                        if (complete && pass.exists(#ShortPickReason) && pass.lookup(#ShortPickReason) == '')
        #                        {
        #                            complete = false;
        #                        }
        #
        #                        if (this.hasError(con))
        #                        {
        #                            ret = con;
        #                            break;
        #                        }
        #                    }
        #                    else
        #                    {
        #                        if (workLine.isFirstPick() && workLine.InventQtyRemain == workLine.InventQtyWork)
        #                        {
        #                            workTable = WHSWorkTable::addTargetLicensePlate(workLine.WorkId, '');
        #
        #                            if (pass.exists(#TargetLicensePlateId))
        #                            {
        #                                pass.remove(#TargetLicensePlateId);
        #                            }
        #                        }
        #
        #                        if (pass.exists(#LicensePlateId))
        #                        {
        #                            pass.remove(#LicensePlateId);
        #                        }
        #
        #                        pass.insert(#SelectedValue, '');
        #
        #                        ret = conNull();
        #                        ret = this.buildShortPick(ret);
        #                    }
        #
        #                    if (!pass.exists(#Initiation) && complete)
        #                    {
        #                        ret = conNull();
        #                        ret = this.buildShortPickConf(ret);
        #                        step = #ShortPickConf;
        #                    }
        #                    else if (!pass.exists(#Initiation))
        #                    {
        #                        ret = conNull();
        #                        ret = this.buildShortPick(ret);
        #                    }
        #
        #                    if (pass.exists(#Initiation))
        #                    {
        #                        pass.remove(#Initiation);
        #                    }
        #                }
        #                catch
        #                {
        #                    ret = conNull();
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                    ret = this.buildShortPick(ret);
        #                }
        #                break;
        #
        #            case #SplitWork:    // Split Work
        #                try
        #                {
        #                    if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).AllowFullSplit)
        #                    {
        #                        if (pass.exists(#FullQty))
        #                        {
        #                            [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
        #                            fieldValues = WHSRFPassthrough::create(tmpFieldValues);
        #                            pass = this.combineMaps(pass, fieldValues);
        #                            [ret, complete] = this.processFieldValues(con, fieldValues);
        #
        #                            if (this.hasError(con) || !complete)
        #                            {
        #                                ret = con;
        #                                break;
        #                            }
        #                        }
        #                        else
        #                        {
        #                            ret = this.buildGetFullQty(ret);
        #                            pass.insert(#FullQty, '');
        #                            break;
        #                        }
        #                    }
        #                    pass.insert(#WorkId, WHSWorkTable::splitWork(pass.lookup(#WorkId), pass.lookupNum(#LineNum), pass.lookupNum(#FullQty)));
        #
        #                    if (mode == WHSWorkExecuteMode::UserGrouping ||
        #                        mode == WHSWorkExecuteMode::SystemGrouping)
        #                    {
        #                        select firstonly forupdate workGrouping
        #                            where workGrouping.WorkId           == workLine.WorkId   &&
        #                                  workGrouping.WorkGroupingId   == pass.lookup(#WorkGroupingId);
        #
        #                        if (workGrouping.RecId != 0)
        #                        {
        #                            ttsbegin;
        #                            workGrouping.WorkId = pass.lookup(#WorkId);
        #                            workGrouping.update();
        #                            ttscommit;
        #                        }
        #                    }
        #                    else if (mode == WHSWorkExecuteMode::PickPack)
        #                    {
        #                        if (pass.exists(#TargetWorkId) && pass.lookup(#TargetWorkId) == workLine.WorkId)
        #                        {
        #                            pass.insert(#TargetWorkId, pass.lookup(#WorkId));
        #                        }
        #
        #                        pass.insert(#PickPackOverride, 1);
        #                        pass.remove(#FullQty);
        #
        #                        con = conPoke(con, 2, pass.pack());
        #                    }
        #
        #                    workLine = workExecute.getFirstOpenLine(pass.lookup(#WorkId), pass.lookup(#UserId));
        #                    ret = this.determineRestart(con);
        #                    recall = true;
        #                }
        #                catch
        #                {
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                    pass = this.resetPassthrough(con, false);
        #                    ret = conPoke(con, 2, pass.pack());
        #                    step = #Restart;
        #                    recall = true;
        #                }
        #                break;
        #
        #            case #ShortPickConf:
        #                try
        #                {
        #                    if (pass.exists(#SuggestLocation))  // User clicked Suggest Location
        #                    {
        #                        ret = conNull();
        #                        ret = this.buildGetLocation(ret, '', _newLocationId);
        #                        pass.insert(#PrevStep, step);
        #                        step = #NoLocation;
        #                    }
        #                    else                                // User clicked OK
        #                    {
        #                        workLine = workExecute.executeShortPick(pass.lookup(#WorkId),
        #                                                                pass.lookupNum(#LineNum),
        #                                                                pass.lookup(#ShortPickReason),
        #                                                                pass.lookupNum(#QtyToPick),
        #                                                                pass.lookup(#UOM),
        #                                                                userId,
        #                                                                pass.exists(#LicensePlateId) ? pass.lookupStr(#LicensePlateId) :
        #                                                                                               pass.lookupStr(#TargetLicensePlateId));
        #
        #                        ret = this.determineRestart(con);
        #
        #                        if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
        #                        {
        #                            throw error("@WAX1459");
        #                        }
        #
        #                        if (pass.exists(#QtyToPick))
        #                        {
        #                            pass.remove(#QtyToPick);
        #                        }
        #
        #                        recall = true;
        #                    }
        #                }
        #                catch
        #                {
        #                    ret = conNull();
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                    ret = this.buildShortPick(ret);
        #                }
        #                break;
        #
        #            case #RFPickingComment:
        #                step = #StepOne;
        #                pass.insert(#CommentsDisplayed, 1);
        #                recall = true;
        #                break;
        #
        #            case #AssignSerialStep:
        #                try
        #                {
        #                    [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
        #                    fieldValues = WHSRFPassthrough::create(tmpFieldValues);
        #                    pass = this.combineMaps(pass, fieldValues);
        #                    [ret, complete] = this.processFieldValues(con, fieldValues);
        #
        #                    if (this.hasError(con))
        #                    {
        #                        ret = con;
        #                        break;
        #                    }
        #
        #                    if (complete)
        #                    {
        #                        this.createAssignSerialDimTracking();
        #
        #                        if (pass.lookupNum(#SerialCounter) < pass.lookupNum(#SerialQty))
        #                        {
        #                            pass.insert(#SerialCounter, pass.lookupNum(#SerialCounter) + 1);
        #
        #                            ret = conNull();
        #                            ret = this.buildAssignSerial(ret);
        #                        }
        #                        else
        #                        {
        #                            step = #Pick;
        #                            pass.remove(#SerialCounter);
        #                            pass.remove(#SerialQty);
        #                            // marks serial as completed, it's used in last build pick step to skip any more prompt for dimensions
        #                            pass.insert(#SkipSerialValidate, #AssignSerialComplete);
        #                            ret = [[mode,step], pass.pack()];
        #                            ret = this.updateModeStepPass(ret, mode, step, pass);
        #                            return this.processWorkLine(workLine, ret, mode, step, userId, _newLocationId, _buttonClicked, _looping);
        #                        }
        #                    }
        #                }
        #                catch
        #                {
        #                    ret = conNull();
        #                    ret = this.buildAssignSerial(ret);
        #                }
        #                break;
        #
        #            case #WorkAuditTemplate:
        #                try
        #                {
        #                    pass.insert(#AuditTemplateId, WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).WorkAuditTemplateId);
        #
        #                    if (!pass.exists(#AuditSeqNum))
        #                    {
        #                        pass.insert(#AuditSeqNum, WHSWorkAuditTemplateTable::getNextTemplateLine(pass.lookup(#AuditTemplateId)).AuditSeqNum);
        #                    }
        #                    // If Audit Seq Num already exists, previous audit function was Capture Data or Display
        #                    else
        #                    {
        #                        workAuditTemplateLine = WHSWorkAuditTemplateLine::find(pass.lookup(#AuditTemplateId), pass.lookup(#AuditSeqNum));
        #
        #                        if (workAuditTemplateLine.AuditBreakFunction == WHSAuditBreakFunction::CaptureData)
        #                        {
        #                            pass.insert(#CustomData, conPeek(conPeek(con, 4), #data));
        #
        #                            if (pass.lookup(#CustomData) != '')
        #                            {
        #                                // Insert data into our audit custom data table
        #                                workAuditCaptureData = WHSWorkAuditCaptureData::create(workTable.WorkId,
        #                                                                                       pass.lookup(#AuditTemplateId),
        #                                                                                       pass.lookup(#AuditSeqNum),
        #                                                                                       pass.lookup(#CustomData));
        #                            }
        #                            else
        #                            {
        #                                // User did not scan anything
        #                                ret = _con;
        #                                break;
        #                            }
        #                        }
        #
        #                        if (!workAuditTemplateLine.WorkAuditTemplateCustomMethod)
        #                        {
        #                            // If not using a custom method on captured data, move on to remaining audit functions
        #                            workAuditTemplateLine = WHSWorkAuditTemplateTable::getNextTemplateLine(pass.lookup(#AuditTemplateId), pass.lookup(#AuditSeqNum));
        #
        #                            if (workAuditTemplateLine.RecId != 0)
        #                            {
        #                                pass.insert(#AuditSeqNum, workAuditTemplateLine.AuditSeqNum);
        #                            }
        #                            else
        #                            {
        #                                pass.insert(#AuditSeqNum, str2int(pass.lookup(#AuditSeqNum)) + 1);
        #                            }
        #                        }
        #                    }
        #
        #                    // Execute Audit Template functions
        #                    [auditSeqNum, auditComplete] = WHSWorkAuditTemplateExecute::execute(pass.lookup(#AuditTemplateId),
        #                                                                                        pass.lookup(#AuditSeqNum),
        #                                                                                        workTable,
        #                                                                                        workAuditCaptureData.RecId);
        #
        #                    // If Capture Data or Display Function, screen must be presented to user
        #                    if (!auditComplete)
        #                    {
        #                        pass.insert(#AuditSeqNum, auditSeqNum);
        #
        #                        ret = conNull();
        #                        ret = this.buildWorkAuditTemplate(ret);
        #                    }
        #                    else
        #                    {
        #                        pass.remove(#AuditSeqNum);
        #
        #                        if (WHSWorkAuditTemplateTable::find(pass.lookup(#AuditTemplateId)).AuditBreakEvent == WHSAuditBreakEvent::Prior)
        #                        {
        #                            if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).PickPack)
        #                            {
        #                                pass.insert(#PickPackOverride, 1);
        #                            }
        #                            step = #StepOne;
        #                            recall = true;
        #                        }
        #                        else
        #                        {
        #                            pass.remove(#AuditWorkId);
        #                            step = #Restart;
        #                            recall = true;
        #                        }
        #                    }
        #                }
        #                catch
        #                {
        #                    ret = conNull();
        #                    ret = this.addErrorLabelFromInfolog(ret, startInfologLine, WHSRFColorText::Error);
        #                    ret = this.addOkButton(ret);
        #                    ret = this.addCancelButton(ret, 1, true);
        #                }
        #                break;
        #        }
        #    }
        #
        #    // Evaluate work audit templates after work completion
        #    if (step == #Restart            &&
        #        step != #WorkAuditTemplate  &&
        #        !pass.exists(#AuditWorkId)  &&
        #        !auditComplete              &&
        #        WHSWorkAuditTemplateTable::evaluateWorkAuditBreak(WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).WorkAuditTemplateId,
        #                                                          workTable,
        #                                                          pass.lookup(#MenuItem),
        #                                                          WHSAuditBreakEvent::Completion,
        #                                                          pass.lookupStr(#WorkGroupingId)))
        #    {
        #        step  = #WorkAuditTemplate;
        #        recall = true;
        #        pass.insert(#AuditWorkId, tmpWorkId);
        #    }
        #
        #    select firstonly autoConfirm
        #        where autoConfirm.MenuItemName  == pass.lookup(#MenuItem)   &&
        #              autoConfirm.WorkType      == preWorkLine.WorkType     &&
        #              autoConfirm.AutoConfirm   == NoYes::Yes;
        #
        #    if (autoConfirm && pass.exists(#AutoConfirm) && !((mode == WHSWorkExecuteMode::PurchaseOrderItemReceivingAndLocate      ||
        #                                                       mode == WHSWorkExecuteMode::PurchaseOrderLineReceivingAndLocate)     &&
        #                                                      preWorkLine.LineNum == 1))
        #    {
        #        pass.remove(#AutoConfirm);
        #        ret = this.updateModeStepPass(ret, mode, step, pass);
        #        return this.processWorkLine(workLine, ret, mode, step, userId, _newLocationId, _buttonClicked, _looping);
        #    }
        #    else if (pass.exists(#GroupPutawayConfirm))
        #    {
        #        pass.remove(#AutoConfirm);
        #        ret = this.updateModeStepPass(ret, mode, step, pass);
        #        return this.processWorkLine(workLine, ret, mode, step, userId, _newLocationId, _buttonClicked, _looping);
        #    }
        #
        #    return [ret, step, recall, pass.pack()];
        #}
      ENDSOURCE
      SOURCE #promptForNegativeBatch
        #/// <summary>
        #/// Method determines if RF user needs to be prompted for batch Id based on negative inventory setup
        #/// </summary>
        #/// <param name="_dimField">
        #/// The current invent dim field we are evaluating to be built on RF screen
        #/// </param>
        #/// <param name="_inventDim">
        #/// The inventDim holding values predetermined by the work.
        #/// </param>
        #/// <param name="_itemId">
        #/// The Id of the item which determines if the inventory is allowed to go negative
        #/// </param>
        #/// <returns>
        #/// true if the user needs to be prompted for batch Id; otherwise false
        #/// </returns>
        #private boolean promptForNegativeBatch(
        #    FieldId     _dimField,
        #    InventDim   _inventDim,
        #    ItemId      _itemId)
        #{
        #    WMSLocation location;
        #    boolean     ret;
        #
        #    location = _inventDim.wmsLocation();
        #
        #    if (_dimField == fieldNum(InventDim, InventBatchId)
        #    &&  !location.whsLocationIsLPControlled()
        #    &&  InventTable::find(_itemId).whsAllowPhysNeg()
        #    &&  location.whsLocationProfile().AllowNegative)
        #    {
        #        ret = true;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #rebuildBatchDisposition
        #/// <summary>
        #///     If an error occurs, rebuild the batch disposition combo box on the RF screen.
        #/// </summary>
        #/// <param name="_con">
        #///     The current RF container variable.
        #/// </param>
        #/// <param name="_controlName">
        #///     The name used to identify the RF control.
        #/// </param>
        #/// <returns>
        #///     Returns the updated RF container variable.
        #/// </returns>
        #protected container rebuildBatchDisposition(container _con, str _controlName = #BatchDisposition)
        #{
        #    container               ret = _con;
        #    str                     elements;
        #    container               batchDisposition;
        #    int                     batchDispLoc;
        #    PdsBatchDispositionCode defaultValue;
        #    PdsBatchDispositionCode selectedValue;
        #    boolean                 showBlank;
        #    ItemId                  itemId;
        #
        #    if (this.displayBatchDisposition())
        #    {
        #        itemId = pass.lookupStr(#ItemId);
        #
        #        // Get the default batch disposition code.
        #        [defaultValue, showBlank] = this.getDefaultBatchDispositionCode(itemId);
        #
        #        elements = this.buildBatchDispositionElements(showBlank);
        #
        #        // Get the location of the batch disposition combo box.
        #        batchDispLoc = this.getControlLocation(ret, _controlName);
        #
        #        if (batchDispLoc > 0)
        #        {
        #            // Find the batch disposition control within the RF container.
        #            batchDisposition = conPeek(ret, batchDispLoc);
        #
        #            // Determine the currently selected value.
        #            selectedValue = conPeek(batchDisposition, #data);
        #
        #            // Remove and reinsert the available elements and selected value for the batch disposition combo box.
        #            batchDisposition = conDel(batchDisposition, #data, 1);
        #            batchDisposition = conIns(batchDisposition, #data, elements);
        #            batchDisposition = conDel(batchDisposition, #selected, 1);
        #            batchDisposition = conIns(batchDisposition, #selected, selectedValue);
        #
        #            ret = conDel(ret, batchDispLoc, 1);
        #            ret = conIns(ret, batchDispLoc, batchDisposition);
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #rebuildDimUOM
        #/// <summary>
        #///     If an error occurs, rebuild the dim UOM combo box on the RF screen.
        #/// </summary>
        #/// <param name="_con">
        #///     The current RF container variable.
        #/// </param>
        #/// <param name="_showBlank">
        #///     A Boolean value to indicate whether a blank value should be included in the list of available options.
        #/// </param>
        #/// <param name="_controlName">
        #///     The name used to identify the RF control.
        #/// </param>
        #/// <returns>
        #///     Returns the updated RF container variable.
        #/// </returns>
        #protected container rebuildDimUOM(
        #    container   _con,
        #    boolean     _showBlank,
        #    str         _controlName = #DimUOM)
        #{
        #    container           ret = _con;
        #    str                 elements;
        #    container           dimUOM;
        #    int                 dimUOMLoc;
        #    UnitOfMeasureSymbol selectedValue;
        #    ItemId              itemId;
        #
        #    if (pass.exists(#ItemId))
        #    {
        #        itemId = pass.lookup(#ItemId);
        #    }
        #
        #    elements = this.buildUOMSequenceGroupString(itemId, _showBlank);
        #
        #    // Get the location of the dimension UOM combo box.
        #    dimUOMLoc = this.getControlLocation(ret, _controlName);
        #
        #    if (dimUOMLoc > 0)
        #    {
        #        // Find the dimension UOM control within the RF container.
        #        dimUOM = conPeek(ret, dimUOMLoc);
        #
        #        // Determine the currently selected value.
        #        selectedValue = conPeek(dimUOM, #data);
        #
        #        dimUOM  = conDel(dimUOM, #data, 1);
        #        dimUOM  = conIns(dimUOM, #data, elements);
        #        dimUOM  = conDel(dimUOM, #selected, 1);
        #        dimUOM  = conIns(dimUOM, #selected, selectedValue);
        #
        #        ret = conDel(ret, dimUOMLoc, 1);
        #        ret = conIns(ret, dimUOMLoc, dimUOM);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #rebuildUseVendBatchDates
        #/// <summary>
        #///     If an error occurs, rebuild the combo boxes on the RF screen.
        #/// </summary>
        #/// <param name="_con">
        #///     The current RF container variable.
        #/// </param>
        #/// <returns>
        #///     Returns the updated RF container variable.
        #/// </returns>
        #protected container rebuildUseVendBatchDates(container _con)
        #{
        #    container   ret = _con;
        #    str         elements;
        #    container   useVendBatchDate;
        #    container   useVendExpDate;
        #    int         useVendBatchDateLoc;
        #    int         useVendExpDateLoc;
        #
        #    elements = this.buildNoYesCombobox();
        #
        #    // Get the locations of the combo boxes used to indicate whether vendor batch date and vendor batch expiry date must be utilized.
        #    useVendBatchDateLoc = this.getControlLocation(ret, #UseVendBatchDate);
        #    useVendExpDateLoc   = this.getControlLocation(ret, #UseVendExpDate);
        #
        #    // Remove and reinsert the available selections for the vendor batch date combo box.
        #    useVendBatchDate    = conPeek(ret, useVendBatchDateLoc);
        #    useVendBatchDate    = conDel(useVendBatchDate, #data, 1);
        #    useVendBatchDate    = conIns(useVendBatchDate, #data, elements);
        #
        #    // Remove and reinsert the available selections for the vendor batch expiry date combo box.
        #    useVendExpDate  = conPeek(ret, useVendExpDateLoc);
        #    useVendExpDate  = conDel(useVendExpDate, #data, 1);
        #    useVendExpDate  = conIns(useVendExpDate, #data, elements);
        #
        #    ret = conDel(ret, useVendBatchDateLoc, 1);
        #    ret = conIns(ret, useVendBatchDateLoc, useVendBatchDate);
        #
        #    ret = conDel(ret, useVendExpDateLoc, 1);
        #    ret = conIns(ret, useVendExpDateLoc, useVendExpDate);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #removeTrackingDimensionsFromPass
        #protected void removeTrackingDimensionsFromPass(ItemId _itemId)
        #{
        #    ListEnumerator  le;
        #    FieldName       fieldName;
        #
        #    le = InventDimGroupSetup::newDimensionGroups(0, 0, InventTable::find(_itemId).trackingDimensionGroup()).activeFields().getEnumerator();
        #
        #    while (le.moveNext())
        #    {
        #        fieldName = fieldId2name(tableNum(InventDim), le.current());
        #
        #        if (pass.exists(fieldName))
        #        {
        #            pass.remove(fieldName);
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #resetButtonClicked
        #container resetButtonClicked(container _con)
        #{
        #    container   con = _con;
        #    str         controlType;
        #    int         length;
        #    int         i;
        #
        #    length = conLen(con);
        #
        #    for (i = 1; i <= length; ++i)
        #    {
        #        controlType = conPeek(conPeek(con, i), #controlType);
        #
        #        if (controlType == #RFButton)
        #        {
        #            con = conPoke(con, i, conPoke(conPeek(con, i), #data, ''));
        #        }
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #resetPassthrough
        #WHSRFPassthrough resetPassthrough(container _con, boolean _useOld = true)
        #{
        #    WHSRFPassthrough    ret;
        #
        #    if (_useOld)
        #    {
        #        return WHSRFPassthrough::create(conPeek(_con, 2));
        #    }
        #
        #    ret = WHSRFPassthrough::newReset(pass);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #setGlobals
        #void setGlobals(WHSWorkExecuteMode  _mode,
        #                int                 _step,
        #                WHSUserId           _userId,
        #                WHSRFPassthrough    _pass,
        #                WHSWorkLine         _workLine = null)
        #{
        #    mode        = _mode;
        #    step        = _step;
        #    userId      = _userId;
        #    pass        = _pass;
        #
        #    if (_workLine)
        #    {
        #        workLine    = _workLine;
        #    }
        #}
      ENDSOURCE
      SOURCE #showDisposition
        #/// <summary>
        #/// Checks, based on current work mode, whether or not a disposition code should be displayed as an option
        #/// </summary>
        #/// <param name="_dispositionTable">
        #/// Disposition record
        #/// </param>
        #/// <returns>
        #/// Boolean dictating if disposition code should be shown in RF
        #/// </returns>
        #private boolean showDisposition(WHSDispositionTable _dispositionTable)
        #{
        #    boolean ret = true;
        #
        #    switch (mode)
        #    {
        #        case WHSWorkExecuteMode::PurchaseOrderItemReceiving:
        #        case WHSWorkExecuteMode::PurchaseOrderItemReceivingAndLocate:
        #        case WHSWorkExecuteMode::PurchaseOrderLineReceiving:
        #        case WHSWorkExecuteMode::PurchaseOrderLineReceivingAndLocate:
        #        case WHSWorkExecuteMode::LicensePlateReceiving:
        #        case WHSWorkExecuteMode::LoadItemReceiving:
        #        case WHSWorkExecuteMode::LoadItemReceivingAndLocate:
        #            if (_dispositionTable.ReturnDispositionCodeId)
        #            {
        #                ret = false;
        #            }
        #            break;
        #        case WHSWorkExecuteMode::ReturnOrder:
        #        case WHSWorkExecuteMode::ReturnOrderAndLocate:
        #            if (!_dispositionTable.ReturnDispositionCodeId
        #            || WHSInventStatus::find(_dispositionTable.InventStatusId).InventStatusBlocking)
        #            {
        #                ret = false;
        #            }
        #            break;
        #        default:
        #            break;
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #updateModeStepPass
        #protected container updateModeStepPass(container _con, WHSWorkExecuteMode _mode, int _step, WHSRFPassthrough _pass = null)
        #{
        #    container           ret = _con;
        #    WHSRFPassthrough    tmpPass = _pass;
        #    int                 i = 1;
        #
        #    if (conLen(conPeek(_con, 1)) != 2)
        #    {
        #        if (tmpPass != null)
        #        {
        #            ret = conIns(ret, 1, tmpPass.pack());
        #        }
        #        else
        #        {
        #            ret = conIns(ret, 1, conNull());
        #        }
        #        ret = conIns(ret, 1, [_mode, _step]);
        #    }
        #    else
        #    {
        #        if (tmpPass != null)
        #        {
        #            ret = conPoke(ret, 2, tmpPass.pack());
        #        }
        #        else
        #        {
        #            ret = conPoke(ret, 2, conNull());
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #validateNonSerialInventory
        #/// <summary>
        #/// Validates that there is enough non-serial inventory to complete the work.
        #/// </summary>
        #/// <param name="_workLine">
        #/// The work to be validated.
        #/// </param>
        #/// <returns>
        #/// True if there is no serial inventory; otherwise false.
        #/// </returns>
        #/// <remarks>
        #/// In this method false is returned when inventory is found because finding inventory is considered
        #/// the invalid scenario.
        #/// </remarks>
        #public boolean validateNonSerialInventory(WHSWorkLine _workLine)
        #{
        #    boolean            ret = true;
        #    InventDim          inventDim;
        #    InventDim          inventDimSelect;
        #    InventSum          inventSum;
        #    InventDimParm      inventDimParm;
        #    WHSRFWhenToCapture whenToCapture;
        #
        #    whenToCapture = WHSInventTable::captureSerial(_workLine.ItemId);
        #
        #    if (!WHSWorkLine::isPutBefore(_workLine.WorkId, _workLine.LineNum)
        #        && (whenToCapture == WHSRFWhenToCapture::Picking
        #        || whenToCapture  == WHSRFWhenToCapture::Packing))
        #    {
        #
        #        inventDim   = InventDim::find(_workLine.InventDimId);
        #        inventDim.InventSerialId = '';
        #        inventDimParm.initFromInventDim(inventDim);
        #
        #        select sum(PhysicalInvent) from inventSum
        #            #InventDimExistsJoin(inventSum.InventDimId, inventDimSelect, inventDim, inventDimParm) &&
        #            inventDimSelect.InventSerialId == '';
        #
        #        if (inventSum.PhysicalInvent < _workLine.InventQtyRemain)
        #        {
        #            ret = false;
        #        }
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #authenticateSession
        #/// <summary>
        #/// Performs authentication of the incoming request.
        #/// </summary>
        #/// <param name="_con">
        #/// Inputs received from the remote client.
        #/// </param>
        #/// <returns>
        #/// Input container which passes the validation process or
        #/// empty one if validation fails.
        #/// </returns>
        #public static container authenticateSession(container _con)
        #{
        #    WHSRFPassthrough        pass;
        #    WHSUserId               userId = '';
        #    WHSWorkUserSessionId    userSessionId = emptyGuid();
        #    WHSWorkUserSession      workUserSession;
        #    int                     mode = 0;
        #    int                     step = 0;
        #    boolean                 isWebRequest = false;
        #
        #    // No data...
        #    if (!_con)
        #    {
        #        return _con;
        #    }
        #
        #    mode = conPeek(conPeek(_con, #StateInfo), #StateInfoMode);
        #    step = conPeek(conPeek(_con, #StateInfo), #StateInfoStep);
        #
        #    // Default mode indicates that the request comes
        #    // from web service and all the data should be retrieved
        #    // from the session database.
        #    if (mode == WHSWorkExecuteMode::WebRequestDefault)
        #    {
        #        isWebRequest = true;
        #        mode = WHSWorkExecuteMode::Login;
        #        step = 0;
        #        _con = conPoke(_con, #StateInfo, [mode, step]);
        #    }
        #
        #    // No session authentication data.
        #    // (that's propagated through the passthrough)
        #    if (conLen(conPeek(_con, #PassthroughInfo)) == 0)
        #    {
        #        if (mode != WHSWorkExecuteMode::Login)
        #        {
        #            return conNull();
        #        }
        #
        #        return _con;
        #    }
        #
        #    pass = WHSRFPassthrough::create(conPeek(_con, #PassthroughInfo));
        #
        #    if (pass.exists(#UserId))
        #    {
        #        userId = pass.lookup(#UserId);
        #    }
        #
        #    if (pass.exists(#UserSessionId))
        #    {
        #        userSessionId = str2guid(pass.lookup(#UserSessionId));
        #    }
        #
        #    if (!userId || !userSessionId)
        #    {
        #        // Login has no userId and sessionId setup
        #        // so if any of them is set we should better
        #        // not pass it through (something is wrong)
        #        if (userId || userSessionId)
        #        {
        #            return conNull();
        #        }
        #
        #        // The only allowed request which can be passed
        #        // with additional data is login request.
        #        // if it's different, something is wrong
        #        // so we don't allow to login.
        #        if (mode != WHSWorkExecuteMode::Login)
        #        {
        #            return conNull();
        #        }
        #
        #        // Data doesn't contain any authentication
        #        // information but is a login request.
        #        if (isWebRequest)
        #        {
        #            // Web requests should not contain any
        #            // pass through information except for
        #            // authentication data.
        #            pass = WHSRFPassthrough::newEmpty();
        #            _con = conPoke(_con, #PassThroughInfo, pass.pack());
        #        }
        #
        #        return _con;
        #    }
        #
        #    // At this point we know we have some authentication data.
        #    workUserSession = WHSWorkUserSession::find(userId);
        #
        #    // Non-existent session
        #    if (!workUserSession || workUserSession.UserSessionId != userSessionId)
        #    {
        #        return conNull();
        #    }
        #
        #    // It is an expensive operation to set the language so we only change if the is a difference.
        #    if (workUserSession.LanguageId
        #    &&  workUserSession.LanguageId != infolog.language())
        #    {
        #        infolog.language(workUserSession.LanguageId);
        #    }
        #
        #    if (isWebRequest)
        #    {
        #        mode = workUserSession.WorkExecuteMode;
        #        step = workUserSession.WorkExecuteStep;
        #        pass = WHSRFPassthrough::create(workUserSession.WorkExecutePassThrough);
        #        pass.insert(#UserId, userId);
        #        pass.insert(#UserSessionId, guid2str(userSessionId));
        #    }
        #
        #    if (!workUserSession.InventLocationId)
        #    {
        #        WHSWorkUserSession::updateWarehouse(userId, WHSWorkUser::find(userId).UserDefaultWarehouse);
        #    }
        #
        #
        #    pass.insert(#InventLocationId, workUserSession.InventLocationId);
        #    pass.insert(#InventSiteId, InventLocation::find(workUserSession.InventLocationId).InventSiteId);
        #
        #    if (workUserSession.PrevPass != conNull())
        #    {
        #        mode = WHSWorkExecuteMode::CycleCounting;
        #    }
        #
        #    _con = conPoke(_con, #StateInfo, [mode, step]);
        #    _con = conPoke(_con, #PassThroughInfo, pass.pack());
        #
        #    return _con;
        #}
      ENDSOURCE
      SOURCE #construct
        #// GOA_00057/ag/16.07.2018 - GOA_00057_Handheld_Outgoing_shipments / Handheld query: Outgoing shipments
        #// GOA_00051/ag/05.06.2018 - GOA_00051_ShipmentGateOutMobile / Shipment gate-out Mobile
        #// GOA_UK_00004/ag/01.12.2017 - GOA_UK_00004_ChangeDimRelocationHandH / Relocation for Handheld
        #// GOA_UK_00003/ag/17.11.2017 - GOA_UK_00003_OnHandHandheld / On-Hand information (Handheld)
        #// GOA_00011/ag/16.11.2017 - GOA_00011_ContainerZoneChangeInWeb / Container Zone Change In Web (HAM Proj)
        #// GOA_UK_00002/ag/06.11.2017 - GOA_UK_00002_WHSLocalTransport / Local transport for Handheld
        #// GOA_00011/ag/25.10.2017 - GOA_00011_ContainerZoneChangeInWeb / Container zone change (Web)
        #// GOA_UK_00001/ag/24.10.2017 -  / Consignment gate out for Vollers-UK
        #static WHSWorkExecuteDisplay construct(WHSWorkExecuteMode _mode)
        #{
        #    switch (_mode)
        #    {
        #        case WHSWorkExecuteMode::Menu                                   : return WHSWorkExecuteDisplayMenu::construct();
        #        case WHSWorkExecuteMode::Login                                  : return WHSWorkExecuteDisplayLogin::construct();
        #        case WHSWorkExecuteMode::UserDirected                           : return WHSWorkExecuteDisplayUserDirected::construct();
        #        case WHSWorkExecuteMode::SystemDirected                         : return WHSWorkExecuteDisplayUserDirected::construct();
        #        case WHSWorkExecuteMode::Movement                               : return WHSWorkExecuteDisplayMovement::construct();
        #        case WHSWorkExecuteMode::MovementByTemplate                     : return WHSWorkExecuteDisplayMovementByTemplate::construct();
        #        case WHSWorkExecuteMode::Quarantine                             : return WHSWorkExecuteDisplayQuarantine::construct();
        #        case WHSWorkExecuteMode::CycleCounting                          : return WHSWorkExecuteDisplayCycleCount::construct();
        #        case WHSWorkExecuteMode::PurchaseOrderLineReceiving             : return WHSWorkExecuteDisplayPOLineReceiving::construct();
        #        case WHSWorkExecuteMode::PurchaseOrderLineReceivingAndLocate    : return WHSWorkExecuteDisplayPOLineReceiving::construct();
        #        case WHSWorkExecuteMode::PurchaseOrderItemReceiving             : return WHSWorkExecuteDisplayPOItemReceiving::construct();
        #        case WHSWorkExecuteMode::PurchaseOrderItemReceivingAndLocate    : return WHSWorkExecuteDisplayPOItemReceiving::construct();
        #        case WHSWorkExecuteMode::LicensePlateReceiving                  : return WHSWorkExecuteDisplayLPReceiving::construct();
        #        case WHSWorkExecuteMode::ReportAsFinished                       : return WHSWorkExecuteDisplayReportAsFinished::construct();
        #        case WHSWorkExecuteMode::ReportAsFinishedAndLocate              : return WHSWorkExecuteDisplayReportAsFinished::construct();
        #        case WHSWorkExecuteMode::KanbanPut                              : return WHSWorkExecuteDisplayKanbanPut::construct();
        #        case WHSWorkExecuteMode::KanbanPutAndLocate                     : return WHSWorkExecuteDisplayKanbanPut::construct();
        #        case WHSWorkExecuteMode::PickPack                               : return WHSWorkExecuteDisplayPickPack::construct();
        #        case WHSWorkExecuteMode::UserGrouping                           : return WHSWorkExecuteDisplayUserGrouping::construct();
        #        case WHSWorkExecuteMode::SystemGrouping                         : return WHSWorkExecuteDisplaySystemGrouping::construct();
        #        case WHSWorkExecuteMode::ValidatedUserDirected                  : return WHSWorkExecuteDisplayValidateUserDirect::construct();
        #        case WHSWorkExecuteMode::AdjustmentIn                           : return WHSWorkExecuteDisplayAdjustIn::construct();
        #        case WHSWorkExecuteMode::AdjustmentOut                          : return WHSWorkExecuteDisplayAdjustOut::construct();
        #        case WHSWorkExecuteMode::ChangeWarehouse                        : return WHSWorkExecuteDisplayChangeWarehouse::construct();
        #        case WHSWorkExecuteMode::InquiryLicensePlate                    : return WHSWorkExecuteDisplayInquiryLP::construct();
        #        case WHSWorkExecuteMode::InquiryLocation                        : return WHSWorkExecuteDisplayInquiryLocation::construct();
        #        case WHSWorkExecuteMode::About                                  : return WHSWorkExecuteDisplayAbout::construct();
        #        case WHSWorkExecuteMode::FlushNumSeqCache                       : return WHSWorkExecuteDisplayFlushNumSeqCache::construct();
        #        case WHSWorkExecuteMode::StartProdOrder                         : return WHSWorkExecuteDisplayProdStart::construct();
        #        case WHSWorkExecuteMode::ProductionScrap                        : return WHSWorkExecuteDisplayProdScrap::construct();
        #        case WHSWorkExecuteMode::ProdLastPallet                         : return WHSWorkExecuteDisplayProdLastPallet::construct();
        #        case WHSWorkExecuteMode::LicensePlateLoading                    : return WHSWorkExecuteDisplayLicensePlateLoad::construct();
        #        case WHSWorkExecuteMode::InquiryItem                            : return WHSWorkExecuteDisplayInquiryItem::construct();
        #        case WHSWorkExecuteMode::ReprintLabel                           : return WHSWorkExecuteDisplayReprintLabel::construct();
        #        case WHSWorkExecuteMode::SpotCycleCounting                      : return WHSWorkExecuteDisplaySpotCycleCounting::construct();
        #        case WHSWorkExecuteMode::ReturnOrder                            : return WHSWorkExecuteDisplayReturnOrder::construct();
        #        case WHSWorkExecuteMode::ReturnOrderAndLocate                   : return WHSWorkExecuteDisplayReturnOrder::construct();
        #        case WHSWorkExecuteMode::WarehouseTransfer                      : return WHSWorkExecuteDisplayWarehouseTransfer::construct();
        #        case WHSWorkExecuteMode::ClusterPicking                         : return WHSWorkExecuteDisplayClusterPicking::construct();
        #        case WHSWorkExecuteMode::LoadItemReceiving                      : return WHSWorkExecuteDisplayLoadItemReceiving::construct();
        #        case WHSWorkExecuteMode::LoadItemReceivingAndLocate             : return WHSWorkExecuteDisplayLoadItemReceiving::construct();
        #        case WHSWorkExecuteMode::TransferOrderItemReceiving             : return WHSWorkExecuteDisplayTOItemReceiving::construct();
        #        case WHSWorkExecuteMode::TransferOrderItemReceivingAndLocate    : return WHSWorkExecuteDisplayTOItemReceiving::construct();
        #        case WHSWorkExecuteMode::TransferOrderLineReceiving             : return WHSWorkExecuteDisplayTOLineReceiving::construct();
        #        case WHSWorkExecuteMode::TransferOrderLineReceivingAndLocate    : return WHSWorkExecuteDisplayTOLineReceiving::construct();
        #        case WHSWorkExecuteMode::LicensePlateBuild                      : return WHSWorkExecuteDisplayLicensePlateBuild::construct();
        #        case WHSWorkExecuteMode::LicensePlateBreak                      : return WHSWorkExecuteDisplayLicensePlateBreak::construct();
        #        case WHSWorkExecuteMode::CycleCountGrouping                     : return WHSWorkExecuteDisplayCycleCountGrouping::construct();
        #        case WHSWorkExecuteMode::DriverCheckIn                          : return WHSWorkExecuteDisplayDriverCheckInOut::construct();
        #        case WHSWorkExecuteMode::DriverCheckOut                         : return WHSWorkExecuteDisplayDriverCheckInOut::construct();
        #        case WHSWorkExecuteMode::ChangeBatchDisposition                 : return WHSWorkExecuteDisplayChangeBatchDisp::construct();
        #
        #        //--> VOL/AG/GOA_00057/16.07.2018
        #        case WHSWorkExecuteMode::GOA_WHSHandheldOutgoingShipments       : return GOA_WHSHandheldOutgoingShipments::construct();
        #        //<-- VOL/AG/GOA_00057/16.07.2018
        #
        #        default                                                         : throw error("@WAX1238");
        #    }
        #}
      ENDSOURCE
      SOURCE #createXML
        #//private static XmlDocument createXML(container _con)
        #protected static XmlDocument createXML(container _con)
        #{
        #    XmlDocument     doc = XmlDocument::newBlank();
        #    XmlNode         root;
        #    XmlNode         controlsNode,
        #                    whsTableNode;
        #    XmlElement      element;
        #    container       con = _con;
        #    container       subCon;
        #    int             length;
        #    int             i;
        #
        #    WHSRFPassthrough pass;
        #    WHSWorkUser     whsWorkUser;
        #    WHSWorker       whsWorker;
        #    HcmWorker       hcmWorker;
        #    DirPartyTable   dirPartyTable;
        #
        #    length = conLen(con);
        #
        #    // Container doesn't have any authentication data
        #    // and controls. Return empty XML
        #    if (length < #PassThroughInfo)
        #    {
        #        return doc;
        #    }
        #
        #    root = doc.createElement(#XMLParentNode);
        #    doc.appendChild(root);
        #
        #    controlsNode = doc.createNode(XmlNodeType::Element, #XMLControlsNode, #XMLControlsNode);
        #    controlsNode = root.appendChild(controlsNode);
        #
        #    whsTableNode = doc.createNode(XmlNodeType::Element, "whsTableNode", "whsTableNode");
        #
        #    // Pass through
        #    subCon = conPeek(con, #PassthroughInfo);
        #    if (conLen(subCon) > 0)
        #    {
        #        pass = WHSRFPassthrough::create(subCon);
        #
        #        if (pass.exists(#UserId) && pass.exists(#UserSessionId))
        #        {
        #            element = doc.createElement(#XMLAuthenticationNode);
        #            element.setAttribute(#XMLAuthNodeUserId, pass.lookup(#UserId));
        #            element.setAttribute(#XMLAuthNodeSessionId, pass.lookup(#UserSessionId));
        #            root.appendChild(element);
        #
        #            // 20161101 SVDH: Added for the WHSportal to know what to add to the user interface on the top of the screen.
        #            if (WHSWorkUserSession::find(pass.lookup(#UserId)).VOL_TerminalId)
        #            {
        #                element = doc.createElement('CurrentTerminal');
        #                element.setAttribute("TerminalId", WHSWorkUserSession::find(pass.lookup(#UserId)).VOL_TerminalId);
        #                if (WHSWorkUserSession::find(pass.lookup(#UserId)).VOL_TerminalId)
        #                {
        #                    element.setAttribute("TerminalIdLabel", "@WHS7");
        #                }
        #                else
        #                {
        #                    element.setAttribute("TerminalIdLabel", "@WHS139");
        #                }
        #                root.appendChild(element);
        #            }
        #        }
        #
        #        // The infolog.language is updated at session authentication
        #        element = doc.createElement(#XMLUserCulture);
        #        if (pass.exists(#UserId))
        #        {
        #            whsWorkUser = WHSWorkUser::find(pass.lookup(#UserId));
        #            whsWorker = WHSWorker::find(whsWorkUser.Worker);
        #            hcmWorker = HcmWorker::find(whsWorker.Worker);
        #            dirPartyTable = DirPartyTable::findRec(hcmWorker.Person);
        #            if(dirPartyTable)
        #            {
        #                element.innerText(dirPartyTable.LanguageId);
        #            }
        #            else
        #            {
        #                element.innerText(infolog.language());
        #            }
        #        }
        #        else
        #        {
        #            element.innerText(infolog.language());
        #        }
        #        root.appendChild(element);
        #    }
        #
        #    // Controls
        #    for (i = #ControlsStart; i <= length; ++i)
        #    {
        #        element = doc.createElement(#XMLControlNode);
        #        subCon = conPeek(con, i);
        #        element.setAttribute(#XMLControlCtrlType, conPeek(subCon, #controlType));
        #        element.setAttribute(#XMLControlName, conPeek(subCon, #name));
        #        element.setAttribute(#XMLControlLabel, conPeek(subCon, #label));
        #        element.setAttribute(#XMLControlNewLine, int2str(conPeek(subCon, #newLine)));
        #        element.setAttribute(#XMLControlData, WHSWorkExecuteDisplay::prepareControlData(conPeek(subCon, #data)));
        #        element.setAttribute(#XMLControlType, conPeek(subCon, #type));
        #        element.setAttribute(#XMLControlLength, int2str(conPeek(subCon, #length)));
        #        element.setAttribute(#XMLControlError, conPeek(subCon, #error));
        #        element.setAttribute(#XMLControlDefaultButton, int2str(conPeek(subCon, #defaultButton)));
        #        element.setAttribute(#XMLControlEnabled, int2str(conPeek(subCon, #enabled)));
        #        element.setAttribute(#XMLControlSelected, conPeek(subCon, #selected));
        #        element.setAttribute(#XMLControlColor, conPeek(subCon, #color));
        #        controlsNode.appendChild(element);
        #    }
        #
        #    return doc;
        #}
      ENDSOURCE
      SOURCE #dictTypeForTableField
        #/// <summary>
        #///    Retrieves the type of a table field.
        #/// </summary>
        #/// <param name="_tableId">
        #///    The table ID of the field.
        #/// </param>
        #/// <param name="_fieldId">
        #///    The field ID.
        #/// </param>
        #/// <returns>
        #///    The type of the field; otherwise, null.
        #/// </returns>
        #/// <remarks>
        #///    The method will return null for fields that are not based on extended data types,
        #///    for example enums.
        #/// </remarks>
        #protected static DictType dictTypeForTableField(
        #    TableId _tableId,
        #    FieldId _fieldId)
        #{
        #    DictTable   dictTable;
        #    DictField   dictField;
        #    DictType    dictType;
        #
        #    if (   _tableId
        #        && _fieldId)
        #    {
        #        dictTable = new DictTable(_tableId);
        #        if (dictTable)
        #        {
        #            dictField = new DictField(dictTable.id(),_fieldId);
        #            if (dictField)
        #            {
        #                if (dictField.typeId())
        #                {
        #                    dictType = new DictType(dictField.typeId());
        #                }
        #            }
        #        }
        #    }
        #
        #    return dictType;
        #}
      ENDSOURCE
      SOURCE #generateWorkUserDisplaySettingsXML
        #static XML generateWorkUserDisplaySettingsXML()
        #{
        #    XmlDocument                 xmlDocument = XmlDocument::newBlank();
        #    XmlNode                     xmlNode;
        #    XmlNode                     settingsNode;
        #    XmlNode                     settingNode;
        #    XmlNode                     nameNode;
        #    XmlNode                     cssFileNode;
        #    XmlNode                     criteriaNode;
        #    XmlNode                     defaultNode;
        #    XmlNode                     viewNode;
        #    XmlNode                     hotkeysNode;
        #    WHSWorkUserDisplaySettings  whsWorkUserDisplaySettings;
        #    xInfo                       xInfo = new xInfo();
        #
        #    xmlNode = xmlDocument.createElement(#Configurations);
        #    xmlDocument.appendChild(xmlNode);
        #
        #    settingsNode = xmlDocument.createElement(#DisplaySettings);
        #    xmlNode.appendChild(settingsNode);
        #
        #    while select whsWorkUserDisplaySettings
        #    {
        #        settingNode = xmlDocument.createElement(#DisplaySetting);
        #        settingsNode.appendChild(settingNode);
        #
        #        nameNode = xmlDocument.createElement(fieldStr(WHSWorkUserDisplaySettings, Name));
        #        nameNode.text(whsWorkUserDisplaySettings.Name);
        #        settingNode.appendChild(nameNode);
        #
        #        cssFileNode = xmlDocument.createElement(fieldStr(WHSWorkUserDisplaySettings, css));
        #        cssFileNode.text(whsWorkUserDisplaySettings.css);
        #        settingNode.appendChild(cssFileNode);
        #
        #        criteriaNode = xmlDocument.createElement(fieldStr(WHSWorkUserDisplaySettings, Criteria));
        #        criteriaNode.text(whsWorkUserDisplaySettings.Criteria);
        #        settingNode.appendChild(criteriaNode);
        #
        #        defaultNode = xmlDocument.createElement(fieldStr(WHSWorkUserDisplaySettings, Default));
        #        defaultNode.text(int2str(whsWorkUserDisplaySettings.Default));
        #        settingNode.appendChild(defaultNode);
        #
        #        viewNode = xmlDocument.createElement(fieldStr(WHSWorkUserDisplaySettings, View));
        #        viewNode.text(whsWorkUserDisplaySettings.View);
        #        settingNode.appendChild(viewNode);
        #
        #        hotkeysNode = xmlDocument.createElement(fieldStr(WHSWorkUserDisplaySettings, Hotkeys));
        #        hotkeysNode.text(whsWorkUserDisplaySettings.Hotkeys);
        #        settingNode.appendChild(hotkeysNode);
        #    }
        #
        #    return xmlDocument.xml();
        #}
      ENDSOURCE
      SOURCE #getNextForm
        #public static server container getNextForm(container _con)
        #{
        #    return conPeek(WHSWorkExecuteDisplay::getNextFormState(_con), 1);
        #}
      ENDSOURCE
      SOURCE #getNextFormHandHeld
        #/// <summary>
        #/// Generates the next form state XML based on the given form state.
        #/// </summary>
        #/// <param name="_xml">
        #/// The current form state as XML.
        #/// </param>
        #/// <returns>
        #/// The next form state as XML.
        #/// </returns>
        #public static str getNextFormHandHeld(str _xml)
        #{
        #    XmlDocument             doc;
        #    container               con;
        #    #CatImpSchema
        #
        #    if (_xml != '' && _xml != #XmlStartElement)
        #    {
        #        doc = XmlDocument::newXml(_xml, false);
        #    }
        #    else
        #    {
        #        doc = XmlDocument::newBlank();
        #    }
        #
        #    con = WHSWorkExecuteDisplay::readXML(doc);
        #    return WHSWorkExecuteDisplay::getNextFormXML(con);
        #}
      ENDSOURCE
      SOURCE #getNextFormState
        #/// <summary>
        #/// Generates the next form state based on the given form state.
        #/// </summary>
        #/// <param name="_con">
        #/// A container with the current form state.
        #/// </param>
        #/// <returns>
        #/// A container with a form state container as the first element
        #/// and an XML representation of the form state, if it was created,
        #/// as the second element.
        #/// </returns>
        #private static server container getNextFormState(container _con)
        #{
        #    WHSWorkExecuteDisplay   workExecuteDisplay;
        #    WHSWorkActivity         workActivity;
        #    WHSMenuItemName         menuItemName;
        #    container               tmp;
        #    container               ret;
        #    container               formContainer;
        #    WHSRFPassthrough        tmpPass;
        #    WHSRFPassthrough        pass;
        #    int                     mode = 0;
        #    int                     step = 0;
        #    str                     buttonClicked = '';
        #    str                     xmlState = '';
        #    WHSWorkUserSession      userSession;
        #
        #
        #    // Session authentication
        #    container               con = WHSWorkExecuteDisplay::authenticateSession(_con);
        #    boolean                 updateSession = false;
        #    WHSUserId               userId = '';
        #    WHSWorkUserSessionId    userSessionId = emptyGuid();
        #
        #
        #    // Read out variables
        #    if (con)
        #    {
        #        mode = conPeek(conPeek(con, #StateInfo), #StateInfoMode);
        #        step = conPeek(conPeek(con, #StateInfo), #StateInfoStep);
        #
        #        tmp = conPeek(con, #PassthroughInfo);
        #        if (conLen(tmp) > 0)
        #        {
        #            pass = WHSRFPassthrough::create(tmp);
        #        }
        #    }
        #
        #    if (!pass)
        #    {
        #       pass = WHSRFPassthrough::newEmpty();
        #    }
        #
        #    if (pass.exists(#UserId))
        #    {
        #        userId = pass.lookup(#UserId);
        #        if (userId && pass.exists(#UserSessionId))
        #        {
        #            userSessionId = str2guid(pass.lookup(#UserSessionId));
        #            updateSession = true;
        #        }
        #    }
        #
        #    workExecuteDisplay = WHSWorkExecuteDisplay::construct(mode);
        #    buttonClicked = workExecuteDisplay.getButtonClicked(con);
        #    workActivity = WHSRFMenuItemTable::find(buttonClicked).WorkActivity;
        #
        #    if (buttonClicked == #RFCancel || workActivity == WHSWorkActivity::LogOff)
        #    {
        #        if (pass && pass.exists(#WorkId))
        #        {
        #            WHSWorkTable::lockUnlockWork(pass.lookup(#WorkId), '');
        #            if (mode == WHSWorkExecuteMode::MovementByTemplate)
        #            {
        #                // Delete Work if we cancel on the first pick of a Movement By Template
        #                if (!pass.exists(#LineNum) || WHSWorkLine::find(pass.lookup(#WorkId), pass.lookupNum(#LineNum)).isFirstPick())
        #                {
        #                    ttsbegin;
        #
        #                    WHSWorkTable::cancelWork(pass.lookup(#WorkId));
        #                    WHSWorkTable::find(pass.lookup(#WorkId), true).delete();
        #
        #                    ttscommit;
        #                }
        #            }
        #            else if (mode == WHSWorkExecuteMode::ClusterPicking && pass.exists(#ClusterId))
        #            {
        #                // Cleanup cluster if user cancels during creation
        #                WHSWorkClusterTable::cleanupCluster(pass.lookup(#ClusterId));
        #            }
        #            else if ((mode == WHSWorkExecuteMode::SystemGrouping    ||
        #                      mode == WHSWorkExecuteMode::UserGrouping)     &&
        #                     pass.exists(#WorkGroupingId))
        #            {
        #                WHSWorkGrouping::cleanupWorkGrouping(pass.lookup(#WorkGroupingId));
        #            }
        #        }
        #
        #        menuItemName = pass.lookupStr(#MenuItem);
        #        pass = WHSRFPassthrough::newEmpty();
        #        pass.insert(#UserId, userId);
        #        pass.insert(#UserSessionId, guid2str(userSessionId));
        #        pass.insert(#MenuItem, menuItemName);
        #        con = conPoke(con, #PassthroughInfo, pass.pack());
        #
        #        if (workActivity == WHSWorkActivity::LogOff)
        #        {
        #            WHSWorkUserSession::deleteSession(userId);
        #            if (pass.exists(#UserId))
        #            {
        #                pass.remove(#UserId);
        #                pass.remove(#UserSessionId);
        #            }
        #            con = conNull();
        #            mode = WHSWorkExecuteMode::Login;
        #            step = 0;
        #            buttonClicked = '';
        #            updateSession = false;
        #            userId = '';
        #            userSessionId = emptyGuid();
        #            workExecuteDisplay = WHSWorkExecuteDisplay::construct(mode);
        #        }
        #        else
        #        {
        #            if (mode == WHSWorkExecuteMode::About || step == 1 || WHSRFMenuItemTable::find(menuItemName).MenuItemDirectedBy == WHSMenuItemDirectedBy::SystemDirected ||
        #                mode == WHSWorkExecuteMode::CycleCounting || mode == WHSWorkExecuteMode::CycleCountingReview || mode == WHSWorkExecuteMode::ClusterPicking ||
        #                (step == 3 && mode == WHSWorkExecuteMode::PurchaseOrderLine) ||
        #                (step == 2 && (mode == WHSWorkExecuteMode::MovementLicensePlate) || (mode == WHSWorkExecuteMode::QuarantineLicensePlate)))
        #            {
        #                mode = WHSWorkExecuteMode::Menu;
        #                step = 0;
        #                con = conPoke(con, #StateInfo, [mode, step]);
        #                workExecuteDisplay = WHSWorkExecuteDisplay::construct(mode);
        #            }
        #            else
        #            {
        #                step = 0;
        #                tmp = conPoke(conPeek(con, #StateInfo), #StateInfoStep, step);
        #                con = conPoke(con, #StateInfo, tmp);
        #            }
        #        }
        #    }
        #
        #    if (buttonClicked == #RFBack)   // Back
        #    {
        #        mode = WHSWorkExecuteMode::Menu;
        #        step = 0;
        #        workExecuteDisplay = WHSWorkExecuteDisplay::construct(mode);
        #    }
        #
        #    // Process the correct flow based on the mode/step combination.
        #    if (!workExecuteDisplay)
        #    {
        #        workExecuteDisplay = WHSWorkExecuteDisplay::construct(mode);
        #    }
        #
        #    workExecuteDisplay.setGlobals(mode, step, userId, pass);
        #    formContainer = workExecuteDisplay.displayForm(con, buttonClicked);
        #    formContainer = workExecuteDisplay.clearClickedButtons(formContainer);
        #
        #    if (mode == WHSWorkExecuteMode::Login && conLen(conPeek(formContainer, #PassthroughInfo)) > 0)
        #    {
        #        tmpPass = WHSRFPassthrough::create(conPeek(formContainer, #PassthroughInfo));
        #        if (!updateSession)
        #        {
        #            updateSession = tmpPass.exists(#OverrideSession);
        #            if (updateSession)
        #            {
        #                tmpPass.remove(#OverrideSession);
        #                formContainer = conPoke(formContainer, #PassthroughInfo, tmpPass.pack());
        #            }
        #        }
        #        else
        #        {
        #            updateSession = !workExecuteDisplay.hasError(formContainer);
        #        }
        #    }
        #
        #
        #    if (updateSession)
        #    {
        #        xmlState = WHSWorkExecuteDisplay::createXML(formContainer).toString();
        #        // The current session language is set on the session authentication step
        #        WHSWorkExecuteDisplay::updateWorkUserSession(userId, formContainer, '', xmlState);
        #    }
        #
        #    ret = [formContainer, xmlState];
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getNextFormXML
        #/// <summary>
        #/// Generates the next form state XML based on the given form state.
        #/// </summary>
        #/// <param name="_con">
        #/// A container with the current form state.
        #/// </param>
        #/// <returns>
        #/// A form state as XML.
        #/// </returns>
        #public static server str getNextFormXML(container _con)
        #{
        #    container   nextFormStateCon;
        #    str         ret;
        #
        #    nextFormStateCon = WHSWorkExecuteDisplay::getNextFormState(_con);
        #
        #    // if the form state is returned as XML then use it, otherwise create it.
        #    if(conLen(nextFormStateCon) > 1 && conPeek(nextFormStateCon, 2) != '')
        #    {
        #        ret = conPeek(nextFormStateCon, 2);
        #    }
        #    else
        #    {
        #        ret = WHSWorkExecuteDisplay::createXML(conPeek(nextFormStateCon, 1)).toString();
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #num2StrDisplay
        #/// <summary>
        #/// Method to convert real number value into a string version to be used during RF processing.
        #/// </summary>
        #/// <param name="_num">
        #/// The real number value that will be converted into a string.
        #/// </param>
        #/// <returns>
        #/// A string representing the passed in real number value.
        #/// </returns>
        #public static str num2StrDisplay(real _num)
        #{
        #    System.Globalization.CultureInfo culture;
        #    str                              result;
        #
        #    culture = System.Globalization.CultureInfo::CreateSpecificCulture(infolog.language());
        #    result  = System.Convert::ToString(_num, culture);
        #
        #    return result;
        #}
      ENDSOURCE
      SOURCE #prepareControlData
        #private static str prepareControlData(anytype _data)
        #{
        #    str result = _data;
        #
        #    switch (typeOf(_data))
        #    {
        #        case Types::Integer:
        #        case Types::Int64:
        #        case Types::Real:
        #            result = WHSWorkExecuteDisplay::num2StrDisplay(_data);
        #            break;
        #    }
        #
        #    return result;
        #}
      ENDSOURCE
      SOURCE #readXML
        #/// <summary>
        #/// Parses given XML document into the internal
        #/// data container format.
        #/// </summary>
        #/// <param name="_doc">
        #/// Document to pars.
        #/// </param>
        #/// <returns>
        #/// Data container with current state information.
        #/// </returns>
        #protected static container readXML(XmlDocument _doc)
        #{
        #    XmlDocument         doc = _doc;
        #    XmlNode             parentNode;
        #    XmlNode             controlNode;
        #    XmlParseError       xmlError;
        #    XmlElement          authenticationElement;
        #    XmlNodeList         controlsList;
        #    XmlElement          controlElement;
        #    int                 i = 0;
        #    container           controlCon;
        #    container           con;
        #    WHSRFPassthrough    pass = new WHSRFPassthrough(Types::String, Types::String);
        #
        #    #define.EmptyXML('<?xml version=\"1.0\" encoding=\"utf-8\"?>')
        #
        #    try
        #    {
        #        if (!doc.xml() || doc.xml() == #EmptyXML)
        #        {
        #            return con;
        #        }
        #
        #        xmlError = doc.parseError();
        #
        #        if (xmlError && xmlError.errorCode() != 0)
        #        {
        #            // if XML is not valid return empty container
        #            // this will redirect user to the login screen.
        #            return conNull();
        #        }
        #
        #        // Get the parent node
        #        parentNode = doc.getNamedElement(#XMLParentNode);
        #
        #        // Add the Mode/Step to the container
        #        con = conIns(con, #StateInfo, [WHSWorkExecuteMode::WebRequestDefault, 0]);
        #
        #        // Add the Pass Through data to the container
        #        authenticationElement = parentNode.getNamedElement(#XMLAuthenticationNode);
        #
        #        if (authenticationElement)
        #        {
        #            pass.insert(#UserId, authenticationElement.getAttribute(#XMLAuthNodeUserId));
        #            pass.insert(#UserSessionId, authenticationElement.getAttribute(#XMLAuthNodeSessionId));
        #        }
        #
        #        con = conIns(con, #PassthroughInfo, pass.pack());
        #
        #        // Add the Controls to the container
        #        controlNode = parentNode.getNamedElement(#XMLControlsNode);
        #        controlsList = controlNode.selectNodes(#XMLControlNode);
        #        controlElement = controlsList.nextNode();
        #
        #        i = #ControlsStart;
        #
        #        while (controlElement != null)
        #        {
        #            controlCon = conNull();
        #            controlCon = conIns(controlCon, 1, controlElement.getAttribute(#XMLControlCtrlType),
        #                                               controlElement.getAttribute(#XMLControlName),
        #                                               controlElement.getAttribute(#XMLControlLabel),
        #                                               controlElement.getAttribute(#XMLControlNewLine),
        #                                               controlElement.getAttribute(#XMLControlData),
        #                                               controlElement.getAttribute(#XMLControlType),
        #                                               controlElement.getAttribute(#XMLControlLength),
        #                                               controlElement.getAttribute(#XMLControlError),
        #                                               controlElement.getAttribute(#XMLControlDefaultButton),
        #                                               controlElement.getAttribute(#XMLControlEnabled),
        #                                               controlElement.getAttribute(#XMLControlSelected),
        #                                               controlElement.getAttribute(#XMLControlColor));
        #            con = conIns(con, i, controlCon);
        #            controlElement = controlsList.nextNode();
        #            ++i;
        #        }
        #    }
        #    catch
        #    {
        #        error("@WAX716");
        #    }
        #
        #    return con;
        #}
      ENDSOURCE
      SOURCE #str2numDisplay
        #/// <summary>
        #/// Method to convert string values representing numbers into real values.
        #/// </summary>
        #/// <param name="_str">
        #/// The string representing a number that will be converted.
        #/// </param>
        #/// <returns>
        #/// A real number value converted from the passed in string.
        #/// </returns>
        #public static real str2numDisplay(str _str)
        #{
        #    real ret;
        #
        #    // The X++ compiler raises a syntax error if a method starts with a .NET method call,
        #    // this empty statement resolves the error.
        #    ;
        #
        #    System.Decimal::TryParse(
        #            _str,
        #            System.Globalization.NumberStyles::Number,
        #            System.Globalization.CultureInfo::CreateSpecificCulture(infolog.language()),
        #            byRef ret);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #updateWorkUserSession
        #/// <summary>
        #/// Updates data in the given user session
        #/// or creates new one if session doesn't exist.
        #/// </summary>
        #/// <param name="_userId">
        #/// Identifier of the user.
        #/// </param>
        #/// <param name="_con">
        #/// Data container.
        #/// </param>
        #/// <param name="_inventLocationId">
        #/// Inventory location value to be set on the session.
        #/// </param>
        #/// <param name="_xml">
        #/// form state XML.
        #/// </param>
        #/// <param name="_languageId">
        #/// The language ID of the user session.
        #/// </param>
        #/// <returns>
        #/// Session that has been updated or created.
        #/// </returns>
        #protected static WHSWorkUserSession updateWorkUserSession(
        #                                                    WHSUserId           _userId,
        #                                                    container           _con,
        #                                                    InventLocationId    _inventLocationId = '',
        #                                                    str                 _xml = '',
        #                                                    LanguageId          _languageId = infolog.language())
        #{
        #    WHSWorkUser whsWorkUser = WHSWorkUser::find(_userId);
        #    WHSWorker   whsWorker;
        #    HcmWorker   hcmWorker;
        #    DirPartyTable   dirPartyTable;
        #
        #    container stateData = conPeek(_con, #StateInfo);
        #
        #    //get hcmworker based on the whsuserid
        #    whsWorker = WHSWorker::find(whsWorkUser.Worker);
        #    hcmWorker = HcmWorker::find(whsWorker.Worker);
        #    dirPartyTable = DirPartyTable::findRec(hcmWorker.Person);
        #    if(dirPartyTable)
        #    {
        #        _languageId = dirPartyTable.LanguageId;
        #    }
        #    if(_xml == '')
        #    {
        #        _xml = WHSWorkExecuteDisplay::createXML(_con).toString();
        #    }
        #
        #    return WHSWorkUserSession::createOrUpdate(_userId,
        #                                                conPeek(stateData, #StateInfoMode),
        #                                                conPeek(stateData, #StateInfoStep),
        #                                                conPeek(_con, #PassThroughInfo),
        #                                                _languageId,
        #                                                _xml,
        #                                                _inventLocationId);
        #}
      ENDSOURCE
      SOURCE #VOL_Version
        #public static FreeTxt VOL_Version()
        #{
        #    FreeTxt versionStr;
        #    str     cr = '\n';
        #    ;
        #
        #    versionStr += @'GOA_00057/ag/16.07.2018 - GOA_00057_Handheld_Outgoing_shipments / Handheld query: Outgoing shipments' + cr;
        #    versionStr += @'       changed construct()' + cr;
        #    versionStr += @'GOA_00051/ag/05.06.2018 - GOA_00051_ShipmentGateOutMobile / Shipment gate-out Mobile' + cr;
        #    versionStr += @'       changed construct()' + cr;
        #    versionStr += 'GOA_UK_00004/ag/05.12.2017 - GOA_UK_00004_ChangeDimRelocationHandH / Relocation for Handheld' + cr;
        #    versionStr += '       changed construct()' + cr;
        #    versionStr += 'GOA_UK_00003/ag/17.11.2017 - GOA_UK_00003_OnHandHandheld / On-Hand information (Handheld)' + cr;
        #    versionStr += '       changed construct()' + cr;
        #    versionStr += 'GOA_UK_00002/ag/06.11.2017 - GOA_UK_00002_WHSLocalTransport / Local transport for Handheld' + cr;
        #    versionStr += '       changed construct()' + cr;
        #    versionStr += 'GOA_00011/ag/26.10.2017 - GOA_00011_ContainerZoneChangeInWeb / Container zone change (Web)' + cr;
        #    versionStr += '       changed construct()' + cr;
        #    versionStr += 'GOA_UK_00010/ag/24.10.2017 -  / Consignment gate out for Vollers-UK' + cr;
        #    versionStr += '       changed construct()' + cr;
        #
        #    return versionStr;
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: END
